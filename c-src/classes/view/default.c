/* default.c generated by valac 0.16.0, the Vala compiler
 * generated from default.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define PDFPC_VIEW_TYPE_BASE (pdfpc_view_base_get_type ())
#define PDFPC_VIEW_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBase))
#define PDFPC_VIEW_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))
#define PDFPC_VIEW_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))

typedef struct _pdfpcViewBase pdfpcViewBase;
typedef struct _pdfpcViewBaseClass pdfpcViewBaseClass;
typedef struct _pdfpcViewBasePrivate pdfpcViewBasePrivate;

#define PDFPC_RENDERER_TYPE_BASE (pdfpc_renderer_base_get_type ())
#define PDFPC_RENDERER_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBase))
#define PDFPC_RENDERER_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))
#define PDFPC_RENDERER_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))

typedef struct _pdfpcRendererBase pdfpcRendererBase;
typedef struct _pdfpcRendererBaseClass pdfpcRendererBaseClass;

#define PDFPC_VIEW_TYPE_PRERENDERING (pdfpc_view_prerendering_get_type ())
#define PDFPC_VIEW_PRERENDERING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_PRERENDERING, pdfpcViewPrerendering))
#define PDFPC_VIEW_IS_PRERENDERING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_PRERENDERING))
#define PDFPC_VIEW_PRERENDERING_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_VIEW_TYPE_PRERENDERING, pdfpcViewPrerenderingIface))

typedef struct _pdfpcViewPrerendering pdfpcViewPrerendering;
typedef struct _pdfpcViewPrerenderingIface pdfpcViewPrerenderingIface;

#define PDFPC_VIEW_BEHAVIOUR_TYPE_DECORATABLE (pdfpc_view_behaviour_decoratable_get_type ())
#define PDFPC_VIEW_BEHAVIOUR_DECORATABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_DECORATABLE, pdfpcViewBehaviourDecoratable))
#define PDFPC_VIEW_BEHAVIOUR_IS_DECORATABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_DECORATABLE))
#define PDFPC_VIEW_BEHAVIOUR_DECORATABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_DECORATABLE, pdfpcViewBehaviourDecoratableIface))

typedef struct _pdfpcViewBehaviourDecoratable pdfpcViewBehaviourDecoratable;
typedef struct _pdfpcViewBehaviourDecoratableIface pdfpcViewBehaviourDecoratableIface;

#define PDFPC_VIEW_BEHAVIOUR_TYPE_BASE (pdfpc_view_behaviour_base_get_type ())
#define PDFPC_VIEW_BEHAVIOUR_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_BASE, pdfpcViewBehaviourBase))
#define PDFPC_VIEW_BEHAVIOUR_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_BEHAVIOUR_TYPE_BASE, pdfpcViewBehaviourBaseClass))
#define PDFPC_VIEW_BEHAVIOUR_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_BASE))
#define PDFPC_VIEW_BEHAVIOUR_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_BEHAVIOUR_TYPE_BASE))
#define PDFPC_VIEW_BEHAVIOUR_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_BEHAVIOUR_TYPE_BASE, pdfpcViewBehaviourBaseClass))

typedef struct _pdfpcViewBehaviourBase pdfpcViewBehaviourBase;
typedef struct _pdfpcViewBehaviourBaseClass pdfpcViewBehaviourBaseClass;

#define PDFPC_VIEW_TYPE_DEFAULT (pdfpc_view_default_get_type ())
#define PDFPC_VIEW_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefault))
#define PDFPC_VIEW_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))
#define PDFPC_VIEW_IS_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_IS_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))

typedef struct _pdfpcViewDefault pdfpcViewDefault;
typedef struct _pdfpcViewDefaultClass pdfpcViewDefaultClass;
typedef struct _pdfpcViewDefaultPrivate pdfpcViewDefaultPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

#define PDFPC_METADATA_TYPE_BASE (pdfpc_metadata_base_get_type ())
#define PDFPC_METADATA_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBase))
#define PDFPC_METADATA_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))
#define PDFPC_METADATA_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))

typedef struct _pdfpcMetadataBase pdfpcMetadataBase;
typedef struct _pdfpcMetadataBaseClass pdfpcMetadataBaseClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define PDFPC_RENDERER_TYPE_CACHING (pdfpc_renderer_caching_get_type ())
#define PDFPC_RENDERER_CACHING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_CACHING, pdfpcRendererCaching))
#define PDFPC_RENDERER_IS_CACHING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_CACHING))
#define PDFPC_RENDERER_CACHING_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_RENDERER_TYPE_CACHING, pdfpcRendererCachingIface))

typedef struct _pdfpcRendererCaching pdfpcRendererCaching;
typedef struct _pdfpcRendererCachingIface pdfpcRendererCachingIface;

#define PDFPC_RENDERER_CACHE_TYPE_BASE (pdfpc_renderer_cache_base_get_type ())
#define PDFPC_RENDERER_CACHE_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBase))
#define PDFPC_RENDERER_CACHE_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))
#define PDFPC_RENDERER_CACHE_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))

typedef struct _pdfpcRendererCacheBase pdfpcRendererCacheBase;
typedef struct _pdfpcRendererCacheBaseClass pdfpcRendererCacheBaseClass;
typedef struct _Block1Data Block1Data;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

typedef enum  {
	PDFPC_RENDERER_RENDER_ERROR_SLIDE_DOES_NOT_EXIST
} pdfpcRendererRenderError;
#define PDFPC_RENDERER_RENDER_ERROR pdfpc_renderer_render_error_quark ()
struct _pdfpcViewBase {
	GtkDrawingArea parent_instance;
	pdfpcViewBasePrivate * priv;
	pdfpcRendererBase* renderer;
};

struct _pdfpcViewBaseClass {
	GtkDrawingAreaClass parent_class;
	void (*display) (pdfpcViewBase* self, gint slide_number, gboolean force_redraw, GError** error);
	void (*fade_to_black) (pdfpcViewBase* self);
	void (*redraw) (pdfpcViewBase* self, GError** error);
	gint (*get_current_slide_number) (pdfpcViewBase* self);
};

struct _pdfpcViewPrerenderingIface {
	GTypeInterface parent_iface;
};

struct _pdfpcViewBehaviourDecoratableIface {
	GTypeInterface parent_iface;
	void (*associate_behaviour) (pdfpcViewBehaviourDecoratable* self, pdfpcViewBehaviourBase* behaviour);
};

struct _pdfpcViewDefault {
	pdfpcViewBase parent_instance;
	pdfpcViewDefaultPrivate * priv;
	gint current_slide_number;
	GdkPixmap* current_slide;
	gint n_slides;
	gint slide_limit;
	GList* behaviours;
};

struct _pdfpcViewDefaultClass {
	pdfpcViewBaseClass parent_class;
};

struct _pdfpcRendererCachingIface {
	GTypeInterface parent_iface;
	void (*set_cache) (pdfpcRendererCaching* self, pdfpcRendererCacheBase* cache);
	pdfpcRendererCacheBase* (*get_cache) (pdfpcRendererCaching* self);
};

struct _Block1Data {
	int _ref_count_;
	pdfpcViewDefault * self;
	gint* i;
	guint page_count;
};

typedef enum  {
	PDFPC_VIEW_BEHAVIOUR_ASSOCIATION_ERROR_BEHAVIOUR_ALREADY_ASSOCIATED,
	PDFPC_VIEW_BEHAVIOUR_ASSOCIATION_ERROR_VIEW_NOT_SUPPORTED
} pdfpcViewBehaviourAssociationError;
#define PDFPC_VIEW_BEHAVIOUR_ASSOCIATION_ERROR pdfpc_view_behaviour_association_error_quark ()

static gpointer pdfpc_view_default_parent_class = NULL;
static pdfpcViewPrerenderingIface* pdfpc_view_default_pdfpc_view_prerendering_parent_iface = NULL;
static pdfpcViewBehaviourDecoratableIface* pdfpc_view_default_pdfpc_view_behaviour_decoratable_parent_iface = NULL;

GType pdfpc_view_base_get_type (void) G_GNUC_CONST;
GQuark pdfpc_renderer_render_error_quark (void);
GType pdfpc_renderer_base_get_type (void) G_GNUC_CONST;
GType pdfpc_view_prerendering_get_type (void) G_GNUC_CONST;
GType pdfpc_view_behaviour_base_get_type (void) G_GNUC_CONST;
GType pdfpc_view_behaviour_decoratable_get_type (void) G_GNUC_CONST;
GType pdfpc_view_default_get_type (void) G_GNUC_CONST;
enum  {
	PDFPC_VIEW_DEFAULT_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
pdfpcViewDefault* pdfpc_view_default_new (pdfpcRendererBase* renderer);
pdfpcViewDefault* pdfpc_view_default_construct (GType object_type, pdfpcRendererBase* renderer);
pdfpcViewBase* pdfpc_view_base_construct (GType object_type, pdfpcRendererBase* renderer);
GType pdfpc_metadata_base_get_type (void) G_GNUC_CONST;
pdfpcMetadataBase* pdfpc_renderer_base_get_metadata (pdfpcRendererBase* self);
guint pdfpc_metadata_base_get_slide_count (pdfpcMetadataBase* self);
static void __lambda5_ (pdfpcViewDefault* self);
void pdfpc_view_base_display (pdfpcViewBase* self, gint slide_number, gboolean force_redraw, GError** error);
GType pdfpc_renderer_cache_base_get_type (void) G_GNUC_CONST;
GType pdfpc_renderer_caching_get_type (void) G_GNUC_CONST;
pdfpcRendererCacheBase* pdfpc_renderer_caching_get_cache (pdfpcRendererCaching* self);
gboolean pdfpc_renderer_cache_base_allows_prerendering (pdfpcRendererCacheBase* self);
void pdfpc_view_default_register_prerendering (pdfpcViewDefault* self);
static void ___lambda5__gtk_widget_realize (GtkWidget* _sender, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
pdfpcRendererBase* pdfpc_view_base_get_renderer (pdfpcViewBase* self);
static gboolean __lambda6_ (Block1Data* _data1_);
GdkPixmap* pdfpc_renderer_base_render_to_pixmap (pdfpcRendererBase* self, gint slide_number, GError** error);
static gboolean ___lambda6__gsource_func (gpointer self);
static void pdfpc_view_default_real_associate_behaviour (pdfpcViewBehaviourDecoratable* base, pdfpcViewBehaviourBase* behaviour);
GQuark pdfpc_view_behaviour_association_error_quark (void);
void pdfpc_view_behaviour_base_associate (pdfpcViewBehaviourBase* self, pdfpcViewBase* target, GError** error);
static void pdfpc_view_default_real_display (pdfpcViewBase* base, gint slide_number, gboolean force_redraw, GError** error);
GdkPixmap* pdfpc_renderer_base_fade_to_black (pdfpcRendererBase* self);
gint pdfpc_renderer_base_get_width (pdfpcRendererBase* self);
gint pdfpc_renderer_base_get_height (pdfpcRendererBase* self);
static void pdfpc_view_default_real_fade_to_black (pdfpcViewBase* base);
static void pdfpc_view_default_real_redraw (pdfpcViewBase* base, GError** error);
static gint pdfpc_view_default_real_get_current_slide_number (pdfpcViewBase* base);
static gboolean pdfpc_view_default_real_expose_event (GtkWidget* base, GdkEventExpose* event);
static void pdfpc_view_default_finalize (GObject* obj);


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


/**
         * Base constructor taking the renderer to use as an argument
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda5_ (pdfpcViewDefault* self) {
	pdfpcRendererBase* _tmp3_;
	pdfpcRendererCaching* _tmp4_;
	pdfpcRendererCaching* caching_renderer;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	pdfpcRendererCaching* _tmp7_;
	gboolean _tmp11_;
	gboolean _tmp16_;
	GError * _inner_error_ = NULL;
	{
		gint _tmp0_;
		_tmp0_ = self->current_slide_number;
		pdfpc_view_base_display ((pdfpcViewBase*) self, _tmp0_, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == PDFPC_RENDERER_RENDER_ERROR) {
				goto __catch6_pdfpc_renderer_render_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally6;
	__catch6_pdfpc_renderer_render_error:
	{
		GError* e = NULL;
		gint _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = self->current_slide_number;
		_tmp2_ = e->message;
		g_error ("default.vala:79: Could not render initial page %d: %s", _tmp1_, _tmp2_);
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = ((pdfpcViewBase*) self)->renderer;
	_tmp4_ = _g_object_ref0 (PDFPC_RENDERER_IS_CACHING (_tmp3_) ? ((pdfpcRendererCaching*) _tmp3_) : NULL);
	caching_renderer = _tmp4_;
	_tmp7_ = caching_renderer;
	if (_tmp7_ != NULL) {
		pdfpcRendererCaching* _tmp8_;
		pdfpcRendererCacheBase* _tmp9_ = NULL;
		pdfpcRendererCacheBase* _tmp10_;
		_tmp8_ = caching_renderer;
		_tmp9_ = pdfpc_renderer_caching_get_cache (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp6_ = _tmp10_ != NULL;
		_g_object_unref0 (_tmp10_);
	} else {
		_tmp6_ = FALSE;
	}
	_tmp11_ = _tmp6_;
	if (_tmp11_) {
		pdfpcRendererCaching* _tmp12_;
		pdfpcRendererCacheBase* _tmp13_ = NULL;
		pdfpcRendererCacheBase* _tmp14_;
		gboolean _tmp15_ = FALSE;
		_tmp12_ = caching_renderer;
		_tmp13_ = pdfpc_renderer_caching_get_cache (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = pdfpc_renderer_cache_base_allows_prerendering (_tmp14_);
		_tmp5_ = _tmp15_;
		_g_object_unref0 (_tmp14_);
	} else {
		_tmp5_ = FALSE;
	}
	_tmp16_ = _tmp5_;
	if (_tmp16_) {
		pdfpc_view_default_register_prerendering (self);
	}
	_g_object_unref0 (caching_renderer);
}


static void ___lambda5__gtk_widget_realize (GtkWidget* _sender, gpointer self) {
	__lambda5_ (self);
}


pdfpcViewDefault* pdfpc_view_default_construct (GType object_type, pdfpcRendererBase* renderer) {
	pdfpcViewDefault * self = NULL;
	pdfpcRendererBase* _tmp0_;
	pdfpcRendererBase* _tmp1_;
	pdfpcMetadataBase* _tmp2_ = NULL;
	pdfpcMetadataBase* _tmp3_;
	guint _tmp4_ = 0U;
	gint _tmp5_;
	g_return_val_if_fail (renderer != NULL, NULL);
	_tmp0_ = renderer;
	self = (pdfpcViewDefault*) pdfpc_view_base_construct (object_type, _tmp0_);
	gtk_widget_set_double_buffered ((GtkWidget*) self, FALSE);
	self->current_slide_number = 0;
	_tmp1_ = renderer;
	_tmp2_ = pdfpc_renderer_base_get_metadata (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = pdfpc_metadata_base_get_slide_count (_tmp3_);
	self->n_slides = (gint) _tmp4_;
	_g_object_unref0 (_tmp3_);
	_tmp5_ = self->n_slides;
	self->slide_limit = _tmp5_ + 1;
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_STRUCTURE_MASK);
	g_signal_connect_object ((GtkWidget*) self, "realize", (GCallback) ___lambda5__gtk_widget_realize, self, 0);
	return self;
}


pdfpcViewDefault* pdfpc_view_default_new (pdfpcRendererBase* renderer) {
	return pdfpc_view_default_construct (PDFPC_VIEW_TYPE_DEFAULT, renderer);
}


/**
         * Start a thread to prerender all slides this view might display at
         * some time.
         *
         * This method may only be called from within the Gtk event loop, as
         * thread handling is borked otherwise.
         */
static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		pdfpcViewDefault * self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda6_ (Block1Data* _data1_) {
	pdfpcViewDefault * self;
	gboolean result = FALSE;
	gint _tmp7_;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	if (_data1_->i == NULL) {
		void* _tmp0_ = NULL;
		gint _tmp1_;
		_tmp0_ = g_malloc ((gsize) sizeof (gint));
		_data1_->i = _tmp0_;
		*_data1_->i = 0;
		_tmp1_ = *_data1_->i;
	}
	{
		pdfpcRendererBase* _tmp2_ = NULL;
		pdfpcRendererBase* _tmp3_;
		GdkPixmap* _tmp4_ = NULL;
		GdkPixmap* _tmp5_;
		_tmp2_ = pdfpc_view_base_get_renderer ((pdfpcViewBase*) self);
		_tmp3_ = _tmp2_;
		_tmp4_ = pdfpc_renderer_base_render_to_pixmap (_tmp3_, *_data1_->i, &_inner_error_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp5_);
		_g_object_unref0 (_tmp3_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == PDFPC_RENDERER_RENDER_ERROR) {
				goto __catch7_pdfpc_renderer_render_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	goto __finally7;
	__catch7_pdfpc_renderer_render_error:
	{
		GError* e = NULL;
		const gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e->message;
		g_error ("default.vala:127: Could not render page '%i' while pre-rendering: %s", *_data1_->i, _tmp6_);
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	g_signal_emit_by_name ((pdfpcViewPrerendering*) self, "slide-prerendered");
	*_data1_->i = (*_data1_->i) + 1;
	_tmp7_ = *_data1_->i;
	if (((guint) (*_data1_->i)) >= _data1_->page_count) {
		g_signal_emit_by_name ((pdfpcViewPrerendering*) self, "prerendering-completed");
		g_free (_data1_->i);
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}


static gboolean ___lambda6__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda6_ (self);
	return result;
}


void pdfpc_view_default_register_prerendering (pdfpcViewDefault* self) {
	Block1Data* _data1_;
	pdfpcRendererBase* _tmp0_ = NULL;
	pdfpcRendererBase* _tmp1_;
	pdfpcMetadataBase* _tmp2_ = NULL;
	pdfpcMetadataBase* _tmp3_;
	guint _tmp4_ = 0U;
	guint _tmp5_;
	g_return_if_fail (self != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->i = NULL;
	_tmp0_ = pdfpc_view_base_get_renderer ((pdfpcViewBase*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = pdfpc_renderer_base_get_metadata (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = pdfpc_metadata_base_get_slide_count (_tmp3_);
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp3_);
	_g_object_unref0 (_tmp1_);
	_data1_->page_count = _tmp5_;
	g_signal_emit_by_name ((pdfpcViewPrerendering*) self, "prerendering-started");
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda6__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


/**
         * Associate a new Behaviour with this View
         *
         * The implementation supports an arbitrary amount of different
         * behaviours.
         */
static void pdfpc_view_default_real_associate_behaviour (pdfpcViewBehaviourDecoratable* base, pdfpcViewBehaviourBase* behaviour) {
	pdfpcViewDefault * self;
	pdfpcViewBehaviourBase* _tmp0_;
	pdfpcViewBehaviourBase* _tmp1_;
	GError * _inner_error_ = NULL;
	self = (pdfpcViewDefault*) base;
	g_return_if_fail (behaviour != NULL);
	_tmp0_ = behaviour;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	self->behaviours = g_list_append (self->behaviours, _tmp1_);
	{
		pdfpcViewBehaviourBase* _tmp2_;
		_tmp2_ = behaviour;
		pdfpc_view_behaviour_base_associate (_tmp2_, (pdfpcViewBase*) self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == PDFPC_VIEW_BEHAVIOUR_ASSOCIATION_ERROR) {
				goto __catch8_pdfpc_view_behaviour_association_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally8;
	__catch8_pdfpc_view_behaviour_association_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e->message;
		g_error ("default.vala:159: Behaviour association failure: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


/**
         * Display a specific slide number
         *
         * If the slide number does not exist a
         * RenderError.SLIDE_DOES_NOT_EXIST is thrown
         */
static void pdfpc_view_default_real_display (pdfpcViewBase* base, gint slide_number, gboolean force_redraw, GError** error) {
	pdfpcViewDefault * self;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	gboolean _tmp9_;
	gboolean _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	gint _tmp22_;
	pdfpcRendererBase* _tmp23_;
	gint _tmp24_ = 0;
	pdfpcRendererBase* _tmp25_;
	gint _tmp26_ = 0;
	gint _tmp27_;
	GError * _inner_error_ = NULL;
	self = (pdfpcViewDefault*) base;
	_tmp0_ = slide_number;
	if (_tmp0_ < 0) {
		slide_number = 0;
	}
	_tmp1_ = slide_number;
	_tmp2_ = self->slide_limit;
	if (_tmp1_ >= _tmp2_) {
		gint _tmp3_;
		_tmp3_ = self->slide_limit;
		slide_number = _tmp3_ - 1;
	}
	_tmp6_ = force_redraw;
	if (!_tmp6_) {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = slide_number;
		_tmp8_ = self->current_slide_number;
		_tmp5_ = _tmp7_ == _tmp8_;
	} else {
		_tmp5_ = FALSE;
	}
	_tmp9_ = _tmp5_;
	if (_tmp9_) {
		GdkPixmap* _tmp10_;
		_tmp10_ = self->current_slide;
		_tmp4_ = _tmp10_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	_tmp11_ = _tmp4_;
	if (_tmp11_) {
		return;
	}
	_tmp12_ = self->current_slide_number;
	_tmp13_ = slide_number;
	g_signal_emit_by_name ((pdfpcViewBase*) self, "leaving-slide", _tmp12_, _tmp13_);
	_tmp14_ = slide_number;
	_tmp15_ = self->n_slides;
	if (_tmp14_ < _tmp15_) {
		pdfpcRendererBase* _tmp16_;
		gint _tmp17_;
		GdkPixmap* _tmp18_ = NULL;
		GdkPixmap* _tmp19_;
		_tmp16_ = ((pdfpcViewBase*) self)->renderer;
		_tmp17_ = slide_number;
		_tmp18_ = pdfpc_renderer_base_render_to_pixmap (_tmp16_, _tmp17_, &_inner_error_);
		_tmp19_ = _tmp18_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == PDFPC_RENDERER_RENDER_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		_g_object_unref0 (self->current_slide);
		self->current_slide = _tmp19_;
	} else {
		pdfpcRendererBase* _tmp20_;
		GdkPixmap* _tmp21_ = NULL;
		_tmp20_ = ((pdfpcViewBase*) self)->renderer;
		_tmp21_ = pdfpc_renderer_base_fade_to_black (_tmp20_);
		_g_object_unref0 (self->current_slide);
		self->current_slide = _tmp21_;
	}
	_tmp22_ = slide_number;
	self->current_slide_number = _tmp22_;
	_tmp23_ = ((pdfpcViewBase*) self)->renderer;
	_tmp24_ = pdfpc_renderer_base_get_width (_tmp23_);
	_tmp25_ = ((pdfpcViewBase*) self)->renderer;
	_tmp26_ = pdfpc_renderer_base_get_height (_tmp25_);
	gtk_widget_queue_draw_area ((GtkWidget*) self, 0, 0, _tmp24_, _tmp26_);
	_tmp27_ = self->current_slide_number;
	g_signal_emit_by_name ((pdfpcViewBase*) self, "entering-slide", _tmp27_);
}


/**
         * Fill everything with black
         */
static void pdfpc_view_default_real_fade_to_black (pdfpcViewBase* base) {
	pdfpcViewDefault * self;
	pdfpcRendererBase* _tmp0_;
	GdkPixmap* _tmp1_ = NULL;
	pdfpcRendererBase* _tmp2_;
	gint _tmp3_ = 0;
	pdfpcRendererBase* _tmp4_;
	gint _tmp5_ = 0;
	self = (pdfpcViewDefault*) base;
	_tmp0_ = ((pdfpcViewBase*) self)->renderer;
	_tmp1_ = pdfpc_renderer_base_fade_to_black (_tmp0_);
	_g_object_unref0 (self->current_slide);
	self->current_slide = _tmp1_;
	_tmp2_ = ((pdfpcViewBase*) self)->renderer;
	_tmp3_ = pdfpc_renderer_base_get_width (_tmp2_);
	_tmp4_ = ((pdfpcViewBase*) self)->renderer;
	_tmp5_ = pdfpc_renderer_base_get_height (_tmp4_);
	gtk_widget_queue_draw_area ((GtkWidget*) self, 0, 0, _tmp3_, _tmp5_);
}


/**
         * Redraw the current slide. Useful for example when exiting from fade_to_black
         */
static void pdfpc_view_default_real_redraw (pdfpcViewBase* base, GError** error) {
	pdfpcViewDefault * self;
	gint _tmp0_;
	GError * _inner_error_ = NULL;
	self = (pdfpcViewDefault*) base;
	_tmp0_ = self->current_slide_number;
	pdfpc_view_base_display ((pdfpcViewBase*) self, _tmp0_, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == PDFPC_RENDERER_RENDER_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


/**
         * Return the currently shown slide number
         */
static gint pdfpc_view_default_real_get_current_slide_number (pdfpcViewBase* base) {
	pdfpcViewDefault * self;
	gint result = 0;
	gint _tmp0_;
	self = (pdfpcViewDefault*) base;
	_tmp0_ = self->current_slide_number;
	result = _tmp0_;
	return result;
}


/**
         * This method is called by Gdk every time the widget needs to be redrawn.
         *
         * The implementation does a simple blit from the internal pixmap to
         * the window surface.
         */
static gboolean pdfpc_view_default_real_expose_event (GtkWidget* base, GdkEventExpose* event) {
	pdfpcViewDefault * self;
	gboolean result = FALSE;
	GdkWindow* _tmp0_;
	cairo_t* _tmp1_ = NULL;
	cairo_t* cr;
	GdkPixmap* _tmp2_;
	GdkEventExpose _tmp3_;
	GdkRectangle _tmp4_;
	gint _tmp5_;
	GdkEventExpose _tmp6_;
	GdkRectangle _tmp7_;
	gint _tmp8_;
	GdkEventExpose _tmp9_;
	GdkRectangle _tmp10_;
	gint _tmp11_;
	GdkEventExpose _tmp12_;
	GdkRectangle _tmp13_;
	gint _tmp14_;
	GdkEventExpose _tmp15_;
	GdkRectangle _tmp16_;
	gint _tmp17_;
	GdkEventExpose _tmp18_;
	GdkRectangle _tmp19_;
	gint _tmp20_;
	self = (pdfpcViewDefault*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = ((GtkWidget*) self)->window;
	_tmp1_ = gdk_cairo_create ((GdkDrawable*) _tmp0_);
	cr = _tmp1_;
	_tmp2_ = self->current_slide;
	_tmp3_ = *event;
	_tmp4_ = _tmp3_.area;
	_tmp5_ = _tmp4_.x;
	_tmp6_ = *event;
	_tmp7_ = _tmp6_.area;
	_tmp8_ = _tmp7_.y;
	gdk_cairo_set_source_pixmap (cr, _tmp2_, (gdouble) _tmp5_, (gdouble) _tmp8_);
	_tmp9_ = *event;
	_tmp10_ = _tmp9_.area;
	_tmp11_ = _tmp10_.x;
	_tmp12_ = *event;
	_tmp13_ = _tmp12_.area;
	_tmp14_ = _tmp13_.y;
	_tmp15_ = *event;
	_tmp16_ = _tmp15_.area;
	_tmp17_ = _tmp16_.width;
	_tmp18_ = *event;
	_tmp19_ = _tmp18_.area;
	_tmp20_ = _tmp19_.height;
	cairo_rectangle (cr, (gdouble) _tmp11_, (gdouble) _tmp14_, (gdouble) _tmp17_, (gdouble) _tmp20_);
	cairo_fill (cr);
	result = TRUE;
	_cairo_destroy0 (cr);
	return result;
}


static void pdfpc_view_default_class_init (pdfpcViewDefaultClass * klass) {
	pdfpc_view_default_parent_class = g_type_class_peek_parent (klass);
	PDFPC_VIEW_BASE_CLASS (klass)->display = pdfpc_view_default_real_display;
	PDFPC_VIEW_BASE_CLASS (klass)->fade_to_black = pdfpc_view_default_real_fade_to_black;
	PDFPC_VIEW_BASE_CLASS (klass)->redraw = pdfpc_view_default_real_redraw;
	PDFPC_VIEW_BASE_CLASS (klass)->get_current_slide_number = pdfpc_view_default_real_get_current_slide_number;
	GTK_WIDGET_CLASS (klass)->expose_event = pdfpc_view_default_real_expose_event;
	G_OBJECT_CLASS (klass)->finalize = pdfpc_view_default_finalize;
}


static void pdfpc_view_default_pdfpc_view_prerendering_interface_init (pdfpcViewPrerenderingIface * iface) {
	pdfpc_view_default_pdfpc_view_prerendering_parent_iface = g_type_interface_peek_parent (iface);
}


static void pdfpc_view_default_pdfpc_view_behaviour_decoratable_interface_init (pdfpcViewBehaviourDecoratableIface * iface) {
	pdfpc_view_default_pdfpc_view_behaviour_decoratable_parent_iface = g_type_interface_peek_parent (iface);
	iface->associate_behaviour = (void (*)(pdfpcViewBehaviourDecoratable*, pdfpcViewBehaviourBase*)) pdfpc_view_default_real_associate_behaviour;
}


static void pdfpc_view_default_instance_init (pdfpcViewDefault * self) {
	self->behaviours = NULL;
}


static void pdfpc_view_default_finalize (GObject* obj) {
	pdfpcViewDefault * self;
	self = PDFPC_VIEW_DEFAULT (obj);
	_g_object_unref0 (self->current_slide);
	__g_list_free__g_object_unref0_0 (self->behaviours);
	G_OBJECT_CLASS (pdfpc_view_default_parent_class)->finalize (obj);
}


/**
     * Basic view class which is usable with any renderer.
     */
GType pdfpc_view_default_get_type (void) {
	static volatile gsize pdfpc_view_default_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_view_default_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcViewDefaultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_view_default_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcViewDefault), 0, (GInstanceInitFunc) pdfpc_view_default_instance_init, NULL };
		static const GInterfaceInfo pdfpc_view_prerendering_info = { (GInterfaceInitFunc) pdfpc_view_default_pdfpc_view_prerendering_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo pdfpc_view_behaviour_decoratable_info = { (GInterfaceInitFunc) pdfpc_view_default_pdfpc_view_behaviour_decoratable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType pdfpc_view_default_type_id;
		pdfpc_view_default_type_id = g_type_register_static (PDFPC_VIEW_TYPE_BASE, "pdfpcViewDefault", &g_define_type_info, 0);
		g_type_add_interface_static (pdfpc_view_default_type_id, PDFPC_VIEW_TYPE_PRERENDERING, &pdfpc_view_prerendering_info);
		g_type_add_interface_static (pdfpc_view_default_type_id, PDFPC_VIEW_BEHAVIOUR_TYPE_DECORATABLE, &pdfpc_view_behaviour_decoratable_info);
		g_once_init_leave (&pdfpc_view_default_type_id__volatile, pdfpc_view_default_type_id);
	}
	return pdfpc_view_default_type_id__volatile;
}



