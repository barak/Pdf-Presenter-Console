/* signal_provider.c generated by valac 0.16.0, the Vala compiler
 * generated from signal_provider.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <poppler.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>


#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER (pdfpc_view_behaviour_pdf_link_signal_provider_get_type ())
#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_SIGNAL_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, pdfpcViewBehaviourPdfLinkSignalProvider))
#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_SIGNAL_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, pdfpcViewBehaviourPdfLinkSignalProviderClass))
#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_IS_SIGNAL_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER))
#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_IS_SIGNAL_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER))
#define PDFPC_VIEW_BEHAVIOUR_PDF_LINK_SIGNAL_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, pdfpcViewBehaviourPdfLinkSignalProviderClass))

typedef struct _pdfpcViewBehaviourPdfLinkSignalProvider pdfpcViewBehaviourPdfLinkSignalProvider;
typedef struct _pdfpcViewBehaviourPdfLinkSignalProviderClass pdfpcViewBehaviourPdfLinkSignalProviderClass;
typedef struct _pdfpcViewBehaviourPdfLinkSignalProviderPrivate pdfpcViewBehaviourPdfLinkSignalProviderPrivate;

#define PDFPC_VIEW_TYPE_BASE (pdfpc_view_base_get_type ())
#define PDFPC_VIEW_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBase))
#define PDFPC_VIEW_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))
#define PDFPC_VIEW_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))

typedef struct _pdfpcViewBase pdfpcViewBase;
typedef struct _pdfpcViewBaseClass pdfpcViewBaseClass;

#define PDFPC_VIEW_TYPE_DEFAULT (pdfpc_view_default_get_type ())
#define PDFPC_VIEW_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefault))
#define PDFPC_VIEW_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))
#define PDFPC_VIEW_IS_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_IS_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))

typedef struct _pdfpcViewDefault pdfpcViewDefault;
typedef struct _pdfpcViewDefaultClass pdfpcViewDefaultClass;

#define PDFPC_VIEW_TYPE_PDF (pdfpc_view_pdf_get_type ())
#define PDFPC_VIEW_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdf))
#define PDFPC_VIEW_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdfClass))
#define PDFPC_VIEW_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_PDF))
#define PDFPC_VIEW_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_PDF))
#define PDFPC_VIEW_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdfClass))

typedef struct _pdfpcViewPdf pdfpcViewPdf;
typedef struct _pdfpcViewPdfClass pdfpcViewPdfClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __vala_PopplerLinkMapping_free0(var) ((var == NULL) ? NULL : (var = (_vala_PopplerLinkMapping_free (var), NULL)))
#define __g_list_free___vala_PopplerLinkMapping_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free___vala_PopplerLinkMapping_free0_ (var), NULL)))

#define PDFPC_RENDERER_TYPE_BASE (pdfpc_renderer_base_get_type ())
#define PDFPC_RENDERER_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBase))
#define PDFPC_RENDERER_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))
#define PDFPC_RENDERER_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))

typedef struct _pdfpcRendererBase pdfpcRendererBase;
typedef struct _pdfpcRendererBaseClass pdfpcRendererBaseClass;

#define PDFPC_RENDERER_TYPE_PDF (pdfpc_renderer_pdf_get_type ())
#define PDFPC_RENDERER_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_PDF, pdfpcRendererPdf))
#define PDFPC_RENDERER_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_TYPE_PDF, pdfpcRendererPdfClass))
#define PDFPC_RENDERER_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_PDF))
#define PDFPC_RENDERER_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_TYPE_PDF))
#define PDFPC_RENDERER_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_TYPE_PDF, pdfpcRendererPdfClass))

typedef struct _pdfpcRendererPdf pdfpcRendererPdf;
typedef struct _pdfpcRendererPdfClass pdfpcRendererPdfClass;

#define PDFPC_METADATA_TYPE_BASE (pdfpc_metadata_base_get_type ())
#define PDFPC_METADATA_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBase))
#define PDFPC_METADATA_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))
#define PDFPC_METADATA_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))

typedef struct _pdfpcMetadataBase pdfpcMetadataBase;
typedef struct _pdfpcMetadataBaseClass pdfpcMetadataBaseClass;

#define PDFPC_METADATA_TYPE_PDF (pdfpc_metadata_pdf_get_type ())
#define PDFPC_METADATA_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdf))
#define PDFPC_METADATA_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))
#define PDFPC_METADATA_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))

typedef struct _pdfpcMetadataPdf pdfpcMetadataPdf;
typedef struct _pdfpcMetadataPdfClass pdfpcMetadataPdfClass;
#define __vala_PopplerDest_free0(var) ((var == NULL) ? NULL : (var = (_vala_PopplerDest_free (var), NULL)))

struct _pdfpcViewBehaviourPdfLinkSignalProvider {
	GObject parent_instance;
	pdfpcViewBehaviourPdfLinkSignalProviderPrivate * priv;
	pdfpcViewPdf* target;
	PopplerLinkMapping* active_mapping;
	GList* page_link_mappings;
	GdkRectangle* precalculated_mapping_rectangles;
	gint precalculated_mapping_rectangles_length1;
};

struct _pdfpcViewBehaviourPdfLinkSignalProviderClass {
	GObjectClass parent_class;
};


static gpointer pdfpc_view_behaviour_pdf_link_signal_provider_parent_class = NULL;
extern GMutex* pdfpc_mutex_locks_poppler;

GType pdfpc_view_behaviour_pdf_link_signal_provider_get_type (void) G_GNUC_CONST;
GType pdfpc_view_base_get_type (void) G_GNUC_CONST;
GType pdfpc_view_default_get_type (void) G_GNUC_CONST;
GType pdfpc_view_pdf_get_type (void) G_GNUC_CONST;
enum  {
	PDFPC_VIEW_BEHAVIOUR_PDF_LINK_SIGNAL_PROVIDER_DUMMY_PROPERTY
};
static void _vala_PopplerLinkMapping_free (PopplerLinkMapping* self);
static void __vala_PopplerLinkMapping_free0_ (gpointer var);
static void _g_list_free___vala_PopplerLinkMapping_free0_ (GList* self);
void pdfpc_view_behaviour_pdf_link_signal_provider_attach (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewPdf* view);
gboolean pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press (pdfpcViewBehaviourPdfLinkSignalProvider* self, GtkWidget* source, GdkEventButton* e);
static gboolean _pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
gboolean pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move (pdfpcViewBehaviourPdfLinkSignalProvider* self, GtkWidget* source, GdkEventMotion* event);
static gboolean _pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
void pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewBase* source, gint page_number);
static void _pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide_pdfpc_view_base_entering_slide (pdfpcViewBase* _sender, gint slide_number, gpointer self);
void pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewBase* source, gint from, gint to);
static void _pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide_pdfpc_view_base_leaving_slide (pdfpcViewBase* _sender, gint from, gint to, gpointer self);
PopplerLinkMapping* pdfpc_view_behaviour_pdf_link_signal_provider_get_link_mapping_by_coordinates (pdfpcViewBehaviourPdfLinkSignalProvider* self, gdouble x, gdouble y);
void pdfpc_view_behaviour_pdf_link_signal_provider_handle_link_mapping (pdfpcViewBehaviourPdfLinkSignalProvider* self, PopplerLinkMapping* mapping);
GType pdfpc_renderer_base_get_type (void) G_GNUC_CONST;
GType pdfpc_renderer_pdf_get_type (void) G_GNUC_CONST;
pdfpcRendererPdf* pdfpc_view_pdf_get_renderer (pdfpcViewPdf* self);
GType pdfpc_metadata_base_get_type (void) G_GNUC_CONST;
pdfpcMetadataBase* pdfpc_renderer_base_get_metadata (pdfpcRendererBase* self);
GType pdfpc_metadata_pdf_get_type (void) G_GNUC_CONST;
PopplerDocument* pdfpc_metadata_pdf_get_document (pdfpcMetadataPdf* self);
static void _vala_PopplerDest_free (PopplerDest* self);
void pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (pdfpcViewBehaviourPdfLinkSignalProvider* self, PopplerRectangle* poppler_rectangle, GdkRectangle* result);
gint pdfpc_view_base_get_current_slide_number (pdfpcViewBase* self);
gdouble pdfpc_metadata_pdf_get_page_width (pdfpcMetadataPdf* self);
gdouble pdfpc_metadata_pdf_get_page_height (pdfpcMetadataPdf* self);
pdfpcRendererBase* pdfpc_view_base_get_renderer (pdfpcViewBase* self);
guint pdfpc_metadata_base_get_slide_count (pdfpcMetadataBase* self);
static PopplerLinkMapping* _vala_PopplerLinkMapping_copy (PopplerLinkMapping* self);
pdfpcViewBehaviourPdfLinkSignalProvider* pdfpc_view_behaviour_pdf_link_signal_provider_new (void);
pdfpcViewBehaviourPdfLinkSignalProvider* pdfpc_view_behaviour_pdf_link_signal_provider_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__BOXED_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__BOXED_UINT_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__BOXED_BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void pdfpc_view_behaviour_pdf_link_signal_provider_finalize (GObject* obj);


static void _vala_PopplerLinkMapping_free (PopplerLinkMapping* self) {
	g_boxed_free (poppler_link_mapping_get_type (), self);
}


static void __vala_PopplerLinkMapping_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (_vala_PopplerLinkMapping_free (var), NULL));
}


static void _g_list_free___vala_PopplerLinkMapping_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) __vala_PopplerLinkMapping_free0_, NULL);
	g_list_free (self);
}


/**
         * Attach a View.Pdf to this signal provider
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press (self, _sender, event);
	return result;
}


static gboolean _pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move (self, _sender, event);
	return result;
}


static void _pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide_pdfpc_view_base_entering_slide (pdfpcViewBase* _sender, gint slide_number, gpointer self) {
	pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide (self, _sender, slide_number);
}


static void _pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide_pdfpc_view_base_leaving_slide (pdfpcViewBase* _sender, gint from, gint to, gpointer self) {
	pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide (self, _sender, from, to);
}


void pdfpc_view_behaviour_pdf_link_signal_provider_attach (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewPdf* view) {
	pdfpcViewPdf* _tmp0_;
	pdfpcViewPdf* _tmp1_;
	pdfpcViewPdf* _tmp2_;
	pdfpcViewPdf* _tmp3_;
	pdfpcViewPdf* _tmp4_;
	pdfpcViewPdf* _tmp5_;
	pdfpcViewPdf* _tmp6_;
	pdfpcViewPdf* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (view != NULL);
	_tmp0_ = view;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->target);
	self->target = _tmp1_;
	_tmp2_ = view;
	gtk_widget_add_events ((GtkWidget*) _tmp2_, (gint) GDK_BUTTON_PRESS_MASK);
	_tmp3_ = view;
	gtk_widget_add_events ((GtkWidget*) _tmp3_, (gint) GDK_POINTER_MOTION_MASK);
	_tmp4_ = view;
	g_signal_connect_object ((GtkWidget*) _tmp4_, "button-press-event", (GCallback) _pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press_gtk_widget_button_press_event, self, 0);
	_tmp5_ = view;
	g_signal_connect_object ((GtkWidget*) _tmp5_, "motion-notify-event", (GCallback) _pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move_gtk_widget_motion_notify_event, self, 0);
	_tmp6_ = view;
	g_signal_connect_object ((pdfpcViewBase*) _tmp6_, "entering-slide", (GCallback) _pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide_pdfpc_view_base_entering_slide, self, 0);
	_tmp7_ = view;
	g_signal_connect_object ((pdfpcViewBase*) _tmp7_, "leaving-slide", (GCallback) _pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide_pdfpc_view_base_leaving_slide, self, 0);
}


/**
         * Return the Poppler.LinkMapping associated with link for the given
         * coordinates.
         *
         * If there is no link for the given coordinates null is returned
         * instead.
         */
PopplerLinkMapping* pdfpc_view_behaviour_pdf_link_signal_provider_get_link_mapping_by_coordinates (pdfpcViewBehaviourPdfLinkSignalProvider* self, gdouble x, gdouble y) {
	PopplerLinkMapping* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				GdkRectangle* _tmp4_;
				gint _tmp4__length1;
				GdkRectangle* _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				GdkRectangle _tmp7_;
				GdkRectangle r;
				gboolean _tmp8_ = FALSE;
				gboolean _tmp9_ = FALSE;
				gboolean _tmp10_ = FALSE;
				gdouble _tmp11_;
				GdkRectangle _tmp12_;
				gint _tmp13_;
				gboolean _tmp19_;
				gboolean _tmp23_;
				gboolean _tmp29_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = self->precalculated_mapping_rectangles;
				_tmp4__length1 = self->precalculated_mapping_rectangles_length1;
				if (!(_tmp3_ < _tmp4__length1)) {
					break;
				}
				_tmp5_ = self->precalculated_mapping_rectangles;
				_tmp5__length1 = self->precalculated_mapping_rectangles_length1;
				_tmp6_ = i;
				_tmp7_ = _tmp5_[_tmp6_];
				r = _tmp7_;
				_tmp11_ = x;
				_tmp12_ = r;
				_tmp13_ = _tmp12_.x;
				if (_tmp11_ >= ((gdouble) _tmp13_)) {
					gdouble _tmp14_;
					GdkRectangle _tmp15_;
					gint _tmp16_;
					GdkRectangle _tmp17_;
					gint _tmp18_;
					_tmp14_ = x;
					_tmp15_ = r;
					_tmp16_ = _tmp15_.x;
					_tmp17_ = r;
					_tmp18_ = _tmp17_.width;
					_tmp10_ = _tmp14_ <= ((gdouble) (_tmp16_ + _tmp18_));
				} else {
					_tmp10_ = FALSE;
				}
				_tmp19_ = _tmp10_;
				if (_tmp19_) {
					gdouble _tmp20_;
					GdkRectangle _tmp21_;
					gint _tmp22_;
					_tmp20_ = y;
					_tmp21_ = r;
					_tmp22_ = _tmp21_.y;
					_tmp9_ = _tmp20_ >= ((gdouble) _tmp22_);
				} else {
					_tmp9_ = FALSE;
				}
				_tmp23_ = _tmp9_;
				if (_tmp23_) {
					gdouble _tmp24_;
					GdkRectangle _tmp25_;
					gint _tmp26_;
					GdkRectangle _tmp27_;
					gint _tmp28_;
					_tmp24_ = y;
					_tmp25_ = r;
					_tmp26_ = _tmp25_.y;
					_tmp27_ = r;
					_tmp28_ = _tmp27_.height;
					_tmp8_ = _tmp24_ <= ((gdouble) (_tmp26_ + _tmp28_));
				} else {
					_tmp8_ = FALSE;
				}
				_tmp29_ = _tmp8_;
				if (_tmp29_) {
					GList* _tmp30_;
					gint _tmp31_;
					gconstpointer _tmp32_ = NULL;
					_tmp30_ = self->page_link_mappings;
					_tmp31_ = i;
					_tmp32_ = g_list_nth_data (_tmp30_, (guint) _tmp31_);
					result = (PopplerLinkMapping*) _tmp32_;
					return result;
				}
			}
		}
	}
	result = NULL;
	return result;
}


/**
         * Handle the given mapping as it has been clicked on.
         *
         * This method evaluates the mapping and emits all signals which are
         * needed in the given case.
         */
static void _vala_PopplerDest_free (PopplerDest* self) {
	g_boxed_free (poppler_dest_get_type (), self);
}


void pdfpc_view_behaviour_pdf_link_signal_provider_handle_link_mapping (pdfpcViewBehaviourPdfLinkSignalProvider* self, PopplerLinkMapping* mapping) {
	PopplerLinkMapping* _tmp0_;
	PopplerAction* _tmp1_;
	PopplerActionType _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mapping != NULL);
	_tmp0_ = mapping;
	_tmp1_ = _tmp0_->action;
	_tmp2_ = _tmp1_->type;
	switch (_tmp2_) {
		case POPPLER_ACTION_GOTO_DEST:
		{
			PopplerLinkMapping* _tmp3_;
			PopplerAction* _tmp4_;
			PopplerActionGotoDest* action;
			PopplerActionGotoDest* _tmp5_;
			PopplerDest* _tmp6_;
			PopplerDestType _tmp7_;
			_tmp3_ = mapping;
			_tmp4_ = _tmp3_->action;
			action = (PopplerActionGotoDest*) _tmp4_;
			_tmp5_ = action;
			_tmp6_ = (*_tmp5_).dest;
			_tmp7_ = _tmp6_->type;
			switch (_tmp7_) {
				case POPPLER_DEST_NAMED:
				{
					GMutex* _tmp8_;
					pdfpcViewPdf* _tmp9_;
					pdfpcRendererPdf* _tmp10_ = NULL;
					pdfpcRendererPdf* _tmp11_;
					pdfpcMetadataBase* _tmp12_ = NULL;
					pdfpcMetadataPdf* _tmp13_;
					pdfpcMetadataPdf* metadata;
					pdfpcMetadataPdf* _tmp14_;
					PopplerDocument* _tmp15_ = NULL;
					PopplerDocument* document;
					PopplerDest* destination = NULL;
					PopplerDocument* _tmp16_;
					PopplerActionGotoDest* _tmp17_;
					PopplerDest* _tmp18_;
					const gchar* _tmp19_;
					PopplerDest* _tmp20_ = NULL;
					GMutex* _tmp21_;
					PopplerLinkMapping* _tmp22_;
					PopplerRectangle _tmp23_;
					GdkRectangle _tmp24_ = {0};
					pdfpcViewPdf* _tmp25_;
					gint _tmp26_ = 0;
					PopplerDest* _tmp27_;
					gint _tmp28_;
					_tmp8_ = pdfpc_mutex_locks_poppler;
					g_mutex_lock (_tmp8_);
					_tmp9_ = self->target;
					_tmp10_ = pdfpc_view_pdf_get_renderer (_tmp9_);
					_tmp11_ = _tmp10_;
					_tmp12_ = pdfpc_renderer_base_get_metadata ((pdfpcRendererBase*) _tmp11_);
					_tmp13_ = PDFPC_METADATA_IS_PDF (_tmp12_) ? ((pdfpcMetadataPdf*) _tmp12_) : NULL;
					_g_object_unref0 (_tmp11_);
					metadata = _tmp13_;
					_tmp14_ = metadata;
					_tmp15_ = pdfpc_metadata_pdf_get_document (_tmp14_);
					document = _tmp15_;
					_tmp16_ = document;
					_tmp17_ = action;
					_tmp18_ = (*_tmp17_).dest;
					_tmp19_ = _tmp18_->named_dest;
					_tmp20_ = poppler_document_find_dest (_tmp16_, _tmp19_);
					__vala_PopplerDest_free0 (destination);
					destination = _tmp20_;
					_tmp21_ = pdfpc_mutex_locks_poppler;
					g_mutex_unlock (_tmp21_);
					_tmp22_ = mapping;
					_tmp23_ = _tmp22_->area;
					pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp23_, &_tmp24_);
					_tmp25_ = self->target;
					_tmp26_ = pdfpc_view_base_get_current_slide_number ((pdfpcViewBase*) _tmp25_);
					_tmp27_ = destination;
					_tmp28_ = _tmp27_->page_num;
					g_signal_emit_by_name (self, "clicked-internal-link", &_tmp24_, (guint) _tmp26_, (guint) (_tmp28_ - 1));
					__vala_PopplerDest_free0 (destination);
					_g_object_unref0 (document);
					_g_object_unref0 (metadata);
					break;
				}
				default:
				break;
			}
			break;
		}
		case POPPLER_ACTION_LAUNCH:
		{
			PopplerLinkMapping* _tmp29_;
			PopplerAction* _tmp30_;
			PopplerActionLaunch* action;
			PopplerLinkMapping* _tmp31_;
			PopplerRectangle _tmp32_;
			GdkRectangle _tmp33_ = {0};
			pdfpcViewPdf* _tmp34_;
			gint _tmp35_ = 0;
			PopplerActionLaunch* _tmp36_;
			const gchar* _tmp37_;
			PopplerActionLaunch* _tmp38_;
			const gchar* _tmp39_;
			_tmp29_ = mapping;
			_tmp30_ = _tmp29_->action;
			action = (PopplerActionLaunch*) _tmp30_;
			_tmp31_ = mapping;
			_tmp32_ = _tmp31_->area;
			pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp32_, &_tmp33_);
			_tmp34_ = self->target;
			_tmp35_ = pdfpc_view_base_get_current_slide_number ((pdfpcViewBase*) _tmp34_);
			_tmp36_ = action;
			_tmp37_ = (*_tmp36_).file_name;
			_tmp38_ = action;
			_tmp39_ = (*_tmp38_).params;
			g_signal_emit_by_name (self, "clicked-external-command", &_tmp33_, (guint) _tmp35_, _tmp37_, _tmp39_);
			break;
		}
		default:
		break;
	}
}


/**
         * Convert an arbitrary Poppler.Rectangle struct into a Gdk.Rectangle
         * struct taking into account the measurement differences between pdf
         * space and screen space.
         */
void pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (pdfpcViewBehaviourPdfLinkSignalProvider* self, PopplerRectangle* poppler_rectangle, GdkRectangle* result) {
	GdkRectangle gdk_rectangle = {0};
	GtkRequisition requisition = {0};
	pdfpcViewPdf* _tmp0_;
	GtkRequisition _tmp1_ = {0};
	pdfpcViewPdf* _tmp2_;
	pdfpcRendererPdf* _tmp3_ = NULL;
	pdfpcRendererPdf* _tmp4_;
	pdfpcMetadataBase* _tmp5_ = NULL;
	pdfpcMetadataPdf* _tmp6_;
	pdfpcMetadataPdf* metadata;
	PopplerRectangle _tmp7_;
	gdouble _tmp8_;
	gdouble _tmp9_ = 0.0;
	GtkRequisition _tmp10_;
	gint _tmp11_;
	gdouble _tmp12_ = 0.0;
	PopplerRectangle _tmp13_;
	gdouble _tmp14_;
	PopplerRectangle _tmp15_;
	gdouble _tmp16_;
	gdouble _tmp17_ = 0.0;
	GtkRequisition _tmp18_;
	gint _tmp19_;
	gdouble _tmp20_ = 0.0;
	gdouble _tmp21_ = 0.0;
	PopplerRectangle _tmp22_;
	gdouble _tmp23_;
	gdouble _tmp24_ = 0.0;
	GtkRequisition _tmp25_;
	gint _tmp26_;
	gdouble _tmp27_ = 0.0;
	PopplerRectangle _tmp28_;
	gdouble _tmp29_;
	PopplerRectangle _tmp30_;
	gdouble _tmp31_;
	gdouble _tmp32_ = 0.0;
	GtkRequisition _tmp33_;
	gint _tmp34_;
	gdouble _tmp35_ = 0.0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (poppler_rectangle != NULL);
	memset (&gdk_rectangle, 0, sizeof (GdkRectangle));
	_tmp0_ = self->target;
	gtk_widget_size_request ((GtkWidget*) _tmp0_, &_tmp1_);
	requisition = _tmp1_;
	_tmp2_ = self->target;
	_tmp3_ = pdfpc_view_pdf_get_renderer (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = pdfpc_renderer_base_get_metadata ((pdfpcRendererBase*) _tmp4_);
	_tmp6_ = PDFPC_METADATA_IS_PDF (_tmp5_) ? ((pdfpcMetadataPdf*) _tmp5_) : NULL;
	_g_object_unref0 (_tmp4_);
	metadata = _tmp6_;
	_tmp7_ = *poppler_rectangle;
	_tmp8_ = _tmp7_.x1;
	_tmp9_ = pdfpc_metadata_pdf_get_page_width (metadata);
	_tmp10_ = requisition;
	_tmp11_ = _tmp10_.width;
	_tmp12_ = ceil ((_tmp8_ / _tmp9_) * _tmp11_);
	gdk_rectangle.x = (gint) _tmp12_;
	_tmp13_ = *poppler_rectangle;
	_tmp14_ = _tmp13_.x2;
	_tmp15_ = *poppler_rectangle;
	_tmp16_ = _tmp15_.x1;
	_tmp17_ = pdfpc_metadata_pdf_get_page_height (metadata);
	_tmp18_ = requisition;
	_tmp19_ = _tmp18_.width;
	_tmp20_ = floor (((_tmp14_ - _tmp16_) / _tmp17_) * _tmp19_);
	gdk_rectangle.width = (gint) _tmp20_;
	_tmp21_ = pdfpc_metadata_pdf_get_page_height (metadata);
	_tmp22_ = *poppler_rectangle;
	_tmp23_ = _tmp22_.y2;
	_tmp24_ = pdfpc_metadata_pdf_get_page_height (metadata);
	_tmp25_ = requisition;
	_tmp26_ = _tmp25_.height;
	_tmp27_ = ceil (((_tmp21_ - _tmp23_) / _tmp24_) * _tmp26_);
	gdk_rectangle.y = (gint) _tmp27_;
	_tmp28_ = *poppler_rectangle;
	_tmp29_ = _tmp28_.y2;
	_tmp30_ = *poppler_rectangle;
	_tmp31_ = _tmp30_.y1;
	_tmp32_ = pdfpc_metadata_pdf_get_page_height (metadata);
	_tmp33_ = requisition;
	_tmp34_ = _tmp33_.height;
	_tmp35_ = floor (((_tmp29_ - _tmp31_) / _tmp32_) * _tmp34_);
	gdk_rectangle.height = (gint) _tmp35_;
	*result = gdk_rectangle;
	_g_object_unref0 (metadata);
	return;
}


/**
         * Called whenever a mouse button is pressed inside the View.Pdf
         *
         * Maybe a link has been clicked. Therefore we need to handle this.
         */
gboolean pdfpc_view_behaviour_pdf_link_signal_provider_on_button_press (pdfpcViewBehaviourPdfLinkSignalProvider* self, GtkWidget* source, GdkEventButton* e) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	guint _tmp1_;
	GdkEventButton _tmp2_;
	gdouble _tmp3_;
	GdkEventButton _tmp4_;
	gdouble _tmp5_;
	PopplerLinkMapping* _tmp6_ = NULL;
	PopplerLinkMapping* mapping;
	PopplerLinkMapping* _tmp7_;
	PopplerLinkMapping* _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = *e;
	_tmp1_ = _tmp0_.button;
	if (_tmp1_ != ((guint) 1)) {
		result = FALSE;
		return result;
	}
	_tmp2_ = *e;
	_tmp3_ = _tmp2_.x;
	_tmp4_ = *e;
	_tmp5_ = _tmp4_.y;
	_tmp6_ = pdfpc_view_behaviour_pdf_link_signal_provider_get_link_mapping_by_coordinates (self, _tmp3_, _tmp5_);
	mapping = _tmp6_;
	_tmp7_ = mapping;
	if (_tmp7_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp8_ = mapping;
	pdfpc_view_behaviour_pdf_link_signal_provider_handle_link_mapping (self, _tmp8_);
	result = TRUE;
	return result;
}


/**
         * Called whenever the mouse is moved on the surface of the View.Pdf
         *
         * The signal emitted by this method may for example be used to change
         * the mouse cursor if the pointer enters or leaves a link
         */
gboolean pdfpc_view_behaviour_pdf_link_signal_provider_on_mouse_move (pdfpcViewBehaviourPdfLinkSignalProvider* self, GtkWidget* source, GdkEventMotion* event) {
	gboolean result = FALSE;
	GdkEventMotion _tmp0_;
	gdouble _tmp1_;
	GdkEventMotion _tmp2_;
	gdouble _tmp3_;
	PopplerLinkMapping* _tmp4_ = NULL;
	PopplerLinkMapping* link_mapping;
	PopplerLinkMapping* _tmp5_;
	gboolean _tmp11_ = FALSE;
	PopplerLinkMapping* _tmp12_;
	gboolean _tmp15_;
	gboolean _tmp16_ = FALSE;
	PopplerLinkMapping* _tmp17_;
	gboolean _tmp19_;
	PopplerLinkMapping* _tmp26_;
	PopplerRectangle _tmp27_;
	GdkRectangle _tmp28_ = {0};
	PopplerLinkMapping* _tmp29_;
	PopplerLinkMapping* _tmp30_;
	PopplerLinkMapping* _tmp31_ = NULL;
	PopplerLinkMapping* _tmp32_;
	PopplerRectangle _tmp33_;
	GdkRectangle _tmp34_ = {0};
	PopplerLinkMapping* _tmp35_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.x;
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.y;
	_tmp4_ = pdfpc_view_behaviour_pdf_link_signal_provider_get_link_mapping_by_coordinates (self, _tmp1_, _tmp3_);
	link_mapping = _tmp4_;
	_tmp5_ = link_mapping;
	if (_tmp5_ == NULL) {
		PopplerLinkMapping* _tmp6_;
		_tmp6_ = self->active_mapping;
		if (_tmp6_ != NULL) {
			PopplerLinkMapping* _tmp7_;
			PopplerRectangle _tmp8_;
			GdkRectangle _tmp9_ = {0};
			PopplerLinkMapping* _tmp10_;
			_tmp7_ = self->active_mapping;
			_tmp8_ = _tmp7_->area;
			pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp8_, &_tmp9_);
			_tmp10_ = self->active_mapping;
			g_signal_emit_by_name (self, "link-mouse-leave", &_tmp9_, _tmp10_);
			__vala_PopplerLinkMapping_free0 (self->active_mapping);
			self->active_mapping = NULL;
		}
		result = FALSE;
		return result;
	}
	_tmp12_ = link_mapping;
	if (_tmp12_ != NULL) {
		PopplerLinkMapping* _tmp13_;
		PopplerLinkMapping* _tmp14_;
		_tmp13_ = link_mapping;
		_tmp14_ = self->active_mapping;
		_tmp11_ = _tmp13_ == _tmp14_;
	} else {
		_tmp11_ = FALSE;
	}
	_tmp15_ = _tmp11_;
	if (_tmp15_) {
		result = FALSE;
		return result;
	}
	_tmp17_ = link_mapping;
	if (_tmp17_ != NULL) {
		PopplerLinkMapping* _tmp18_;
		_tmp18_ = self->active_mapping;
		_tmp16_ = _tmp18_ == NULL;
	} else {
		_tmp16_ = FALSE;
	}
	_tmp19_ = _tmp16_;
	if (_tmp19_) {
		PopplerLinkMapping* _tmp20_;
		PopplerLinkMapping* _tmp21_ = NULL;
		PopplerLinkMapping* _tmp22_;
		PopplerRectangle _tmp23_;
		GdkRectangle _tmp24_ = {0};
		PopplerLinkMapping* _tmp25_;
		_tmp20_ = link_mapping;
		_tmp21_ = poppler_link_mapping_copy (_tmp20_);
		__vala_PopplerLinkMapping_free0 (self->active_mapping);
		self->active_mapping = _tmp21_;
		_tmp22_ = self->active_mapping;
		_tmp23_ = _tmp22_->area;
		pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp23_, &_tmp24_);
		_tmp25_ = self->active_mapping;
		g_signal_emit_by_name (self, "link-mouse-enter", &_tmp24_, _tmp25_);
		result = FALSE;
		return result;
	}
	_tmp26_ = self->active_mapping;
	_tmp27_ = _tmp26_->area;
	pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp27_, &_tmp28_);
	_tmp29_ = self->active_mapping;
	g_signal_emit_by_name (self, "link-mouse-leave", &_tmp28_, _tmp29_);
	_tmp30_ = link_mapping;
	_tmp31_ = poppler_link_mapping_copy (_tmp30_);
	__vala_PopplerLinkMapping_free0 (self->active_mapping);
	self->active_mapping = _tmp31_;
	_tmp32_ = self->active_mapping;
	_tmp33_ = _tmp32_->area;
	pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp33_, &_tmp34_);
	_tmp35_ = self->active_mapping;
	g_signal_emit_by_name (self, "link-mouse-enter", &_tmp34_, _tmp35_);
	result = FALSE;
	return result;
}


/**
         * Handle newly entered pdf pages to create a link mapping table for
         * further requests and checks.
         */
static PopplerLinkMapping* _vala_PopplerLinkMapping_copy (PopplerLinkMapping* self) {
	return g_boxed_copy (poppler_link_mapping_get_type (), self);
}


static gpointer __vala_PopplerLinkMapping_copy0 (gpointer self) {
	return self ? _vala_PopplerLinkMapping_copy (self) : NULL;
}


void pdfpc_view_behaviour_pdf_link_signal_provider_on_entering_slide (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewBase* source, gint page_number) {
	gboolean in_range;
	GMutex* _tmp0_;
	pdfpcViewBase* _tmp1_;
	pdfpcRendererBase* _tmp2_ = NULL;
	pdfpcRendererBase* _tmp3_;
	pdfpcMetadataBase* _tmp4_ = NULL;
	pdfpcMetadataPdf* _tmp5_;
	pdfpcMetadataPdf* metadata;
	gint _tmp6_;
	pdfpcMetadataPdf* _tmp7_;
	guint _tmp8_ = 0U;
	GMutex* _tmp17_;
	gboolean _tmp18_;
	GList* _tmp19_;
	guint _tmp20_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	in_range = TRUE;
	_tmp0_ = pdfpc_mutex_locks_poppler;
	g_mutex_lock (_tmp0_);
	_tmp1_ = source;
	_tmp2_ = pdfpc_view_base_get_renderer (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = pdfpc_renderer_base_get_metadata (_tmp3_);
	_tmp5_ = PDFPC_METADATA_IS_PDF (_tmp4_) ? ((pdfpcMetadataPdf*) _tmp4_) : NULL;
	_g_object_unref0 (_tmp3_);
	metadata = _tmp5_;
	_tmp6_ = page_number;
	_tmp7_ = metadata;
	_tmp8_ = pdfpc_metadata_base_get_slide_count ((pdfpcMetadataBase*) _tmp7_);
	if (((guint) _tmp6_) < _tmp8_) {
		pdfpcMetadataPdf* _tmp9_;
		PopplerDocument* _tmp10_ = NULL;
		PopplerDocument* _tmp11_;
		gint _tmp12_;
		PopplerPage* _tmp13_ = NULL;
		PopplerPage* _tmp14_;
		PopplerPage* page;
		PopplerPage* _tmp15_;
		GList* _tmp16_ = NULL;
		_tmp9_ = metadata;
		_tmp10_ = pdfpc_metadata_pdf_get_document (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = page_number;
		_tmp13_ = poppler_document_get_page (_tmp11_, _tmp12_);
		_tmp14_ = _tmp13_;
		_g_object_unref0 (_tmp11_);
		page = _tmp14_;
		_tmp15_ = page;
		_tmp16_ = poppler_page_get_link_mapping (_tmp15_);
		__g_list_free___vala_PopplerLinkMapping_free0_0 (self->page_link_mappings);
		self->page_link_mappings = _tmp16_;
		_g_object_unref0 (page);
	} else {
		__g_list_free___vala_PopplerLinkMapping_free0_0 (self->page_link_mappings);
		self->page_link_mappings = NULL;
		in_range = FALSE;
	}
	_tmp17_ = pdfpc_mutex_locks_poppler;
	g_mutex_unlock (_tmp17_);
	_tmp18_ = in_range;
	if (!_tmp18_) {
		_g_object_unref0 (metadata);
		return;
	}
	_tmp19_ = self->page_link_mappings;
	_tmp20_ = g_list_length (_tmp19_);
	if (_tmp20_ > ((guint) 0)) {
		GList* _tmp21_;
		guint _tmp22_ = 0U;
		GdkRectangle* _tmp23_ = NULL;
		gint i;
		GList* _tmp24_;
		_tmp21_ = self->page_link_mappings;
		_tmp22_ = g_list_length (_tmp21_);
		_tmp23_ = g_new0 (GdkRectangle, _tmp22_);
		self->precalculated_mapping_rectangles = (g_free (self->precalculated_mapping_rectangles), NULL);
		self->precalculated_mapping_rectangles = _tmp23_;
		self->precalculated_mapping_rectangles_length1 = _tmp22_;
		i = 0;
		_tmp24_ = self->page_link_mappings;
		{
			GList* mapping_collection = NULL;
			GList* mapping_it = NULL;
			mapping_collection = _tmp24_;
			for (mapping_it = mapping_collection; mapping_it != NULL; mapping_it = mapping_it->next) {
				PopplerLinkMapping* _tmp25_;
				PopplerLinkMapping* mapping = NULL;
				_tmp25_ = __vala_PopplerLinkMapping_copy0 ((PopplerLinkMapping*) mapping_it->data);
				mapping = _tmp25_;
				{
					GdkRectangle* _tmp26_;
					gint _tmp26__length1;
					gint _tmp27_;
					PopplerLinkMapping* _tmp28_;
					PopplerRectangle _tmp29_;
					GdkRectangle _tmp30_ = {0};
					GdkRectangle _tmp31_;
					_tmp26_ = self->precalculated_mapping_rectangles;
					_tmp26__length1 = self->precalculated_mapping_rectangles_length1;
					_tmp27_ = i;
					i = _tmp27_ + 1;
					_tmp28_ = mapping;
					_tmp29_ = _tmp28_->area;
					pdfpc_view_behaviour_pdf_link_signal_provider_convert_poppler_rectangle_to_gdk_rectangle (self, &_tmp29_, &_tmp30_);
					_tmp26_[_tmp27_] = _tmp30_;
					_tmp31_ = _tmp26_[_tmp27_];
					__vala_PopplerLinkMapping_free0 (mapping);
				}
			}
		}
	}
	_g_object_unref0 (metadata);
}


/**
         * Free the allocated link mapping tables, which were created on page
         * entering
         */
void pdfpc_view_behaviour_pdf_link_signal_provider_on_leaving_slide (pdfpcViewBehaviourPdfLinkSignalProvider* self, pdfpcViewBase* source, gint from, gint to) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	self->precalculated_mapping_rectangles = (g_free (self->precalculated_mapping_rectangles), NULL);
	self->precalculated_mapping_rectangles = NULL;
	self->precalculated_mapping_rectangles_length1 = 0;
}


pdfpcViewBehaviourPdfLinkSignalProvider* pdfpc_view_behaviour_pdf_link_signal_provider_construct (GType object_type) {
	pdfpcViewBehaviourPdfLinkSignalProvider * self = NULL;
	self = (pdfpcViewBehaviourPdfLinkSignalProvider*) g_object_new (object_type, NULL);
	return self;
}


pdfpcViewBehaviourPdfLinkSignalProvider* pdfpc_view_behaviour_pdf_link_signal_provider_new (void) {
	return pdfpc_view_behaviour_pdf_link_signal_provider_construct (PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER);
}


static void g_cclosure_user_marshal_VOID__BOXED_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED_UINT_UINT) (gpointer data1, gpointer arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__BOXED_UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED_UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_uint (param_values + 2), g_value_get_uint (param_values + 3), data2);
}


static void g_cclosure_user_marshal_VOID__BOXED_UINT_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED_UINT_STRING_STRING) (gpointer data1, gpointer arg_1, guint arg_2, const char* arg_3, const char* arg_4, gpointer data2);
	register GMarshalFunc_VOID__BOXED_UINT_STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED_UINT_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_uint (param_values + 2), g_value_get_string (param_values + 3), g_value_get_string (param_values + 4), data2);
}


static void g_cclosure_user_marshal_VOID__BOXED_BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED_BOXED) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__BOXED_BOXED callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED_BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_boxed (param_values + 2), data2);
}


static void pdfpc_view_behaviour_pdf_link_signal_provider_class_init (pdfpcViewBehaviourPdfLinkSignalProviderClass * klass) {
	pdfpc_view_behaviour_pdf_link_signal_provider_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = pdfpc_view_behaviour_pdf_link_signal_provider_finalize;
	/**
	         * Emitted whenever a link on a pdf page is clicked, which should
	         * trigger a document internal switch to another page.
	         */
	g_signal_new ("clicked_internal_link", PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_UINT_UINT, G_TYPE_NONE, 3, GDK_TYPE_RECTANGLE, G_TYPE_UINT, G_TYPE_UINT);
	/**
	         * Emitted whenever a link on a pdf page is clicked, which should
	         * execute an external command.
	         *
	         * Be careful while handling these, as requested code to be execute may
	         * be malicious.
	         */
	g_signal_new ("clicked_external_command", PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_UINT_STRING_STRING, G_TYPE_NONE, 4, GDK_TYPE_RECTANGLE, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRING);
	/**
	         * Emitted whenever the mouse entered a pdf link
	         */
	g_signal_new ("link_mouse_enter", PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_BOXED, G_TYPE_NONE, 2, GDK_TYPE_RECTANGLE, poppler_link_mapping_get_type ());
	/**
	         * Emitted whenever the mouse left a pdf link
	         */
	g_signal_new ("link_mouse_leave", PDFPC_VIEW_BEHAVIOUR_PDF_LINK_TYPE_SIGNAL_PROVIDER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_BOXED, G_TYPE_NONE, 2, GDK_TYPE_RECTANGLE, poppler_link_mapping_get_type ());
}


static void pdfpc_view_behaviour_pdf_link_signal_provider_instance_init (pdfpcViewBehaviourPdfLinkSignalProvider * self) {
	self->target = NULL;
	self->active_mapping = NULL;
	self->page_link_mappings = NULL;
	self->precalculated_mapping_rectangles = NULL;
}


static void pdfpc_view_behaviour_pdf_link_signal_provider_finalize (GObject* obj) {
	pdfpcViewBehaviourPdfLinkSignalProvider * self;
	self = PDFPC_VIEW_BEHAVIOUR_PDF_LINK_SIGNAL_PROVIDER (obj);
	_g_object_unref0 (self->target);
	__vala_PopplerLinkMapping_free0 (self->active_mapping);
	__g_list_free___vala_PopplerLinkMapping_free0_0 (self->page_link_mappings);
	self->precalculated_mapping_rectangles = (g_free (self->precalculated_mapping_rectangles), NULL);
	G_OBJECT_CLASS (pdfpc_view_behaviour_pdf_link_signal_provider_parent_class)->finalize (obj);
}


/**
     * Access provider to all signals related to PDF links.
     */
GType pdfpc_view_behaviour_pdf_link_signal_provider_get_type (void) {
	static volatile gsize pdfpc_view_behaviour_pdf_link_signal_provider_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_view_behaviour_pdf_link_signal_provider_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcViewBehaviourPdfLinkSignalProviderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_view_behaviour_pdf_link_signal_provider_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcViewBehaviourPdfLinkSignalProvider), 0, (GInstanceInitFunc) pdfpc_view_behaviour_pdf_link_signal_provider_instance_init, NULL };
		GType pdfpc_view_behaviour_pdf_link_signal_provider_type_id;
		pdfpc_view_behaviour_pdf_link_signal_provider_type_id = g_type_register_static (G_TYPE_OBJECT, "pdfpcViewBehaviourPdfLinkSignalProvider", &g_define_type_info, 0);
		g_once_init_leave (&pdfpc_view_behaviour_pdf_link_signal_provider_type_id__volatile, pdfpc_view_behaviour_pdf_link_signal_provider_type_id);
	}
	return pdfpc_view_behaviour_pdf_link_signal_provider_type_id__volatile;
}



