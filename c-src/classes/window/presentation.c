/* presentation.c generated by valac 0.16.0, the Vala compiler
 * generated from presentation.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>


#define PDFPC_WINDOW_TYPE_FULLSCREEN (pdfpc_window_fullscreen_get_type ())
#define PDFPC_WINDOW_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreen))
#define PDFPC_WINDOW_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))
#define PDFPC_WINDOW_IS_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_IS_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_FULLSCREEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))

typedef struct _pdfpcWindowFullscreen pdfpcWindowFullscreen;
typedef struct _pdfpcWindowFullscreenClass pdfpcWindowFullscreenClass;
typedef struct _pdfpcWindowFullscreenPrivate pdfpcWindowFullscreenPrivate;

#define PDFPC_TYPE_CONTROLLABLE (pdfpc_controllable_get_type ())
#define PDFPC_CONTROLLABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_TYPE_CONTROLLABLE, pdfpcControllable))
#define PDFPC_IS_CONTROLLABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_TYPE_CONTROLLABLE))
#define PDFPC_CONTROLLABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_TYPE_CONTROLLABLE, pdfpcControllableIface))

typedef struct _pdfpcControllable pdfpcControllable;
typedef struct _pdfpcControllableIface pdfpcControllableIface;

#define PDFPC_TYPE_PRESENTATION_CONTROLLER (pdfpc_presentation_controller_get_type ())
#define PDFPC_PRESENTATION_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationController))
#define PDFPC_PRESENTATION_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationControllerClass))
#define PDFPC_IS_PRESENTATION_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER))
#define PDFPC_IS_PRESENTATION_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_TYPE_PRESENTATION_CONTROLLER))
#define PDFPC_PRESENTATION_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationControllerClass))

typedef struct _pdfpcPresentationController pdfpcPresentationController;
typedef struct _pdfpcPresentationControllerClass pdfpcPresentationControllerClass;

#define PDFPC_WINDOW_TYPE_PRESENTATION (pdfpc_window_presentation_get_type ())
#define PDFPC_WINDOW_PRESENTATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_PRESENTATION, pdfpcWindowPresentation))
#define PDFPC_WINDOW_PRESENTATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_PRESENTATION, pdfpcWindowPresentationClass))
#define PDFPC_WINDOW_IS_PRESENTATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_PRESENTATION))
#define PDFPC_WINDOW_IS_PRESENTATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_PRESENTATION))
#define PDFPC_WINDOW_PRESENTATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_PRESENTATION, pdfpcWindowPresentationClass))

typedef struct _pdfpcWindowPresentation pdfpcWindowPresentation;
typedef struct _pdfpcWindowPresentationClass pdfpcWindowPresentationClass;
typedef struct _pdfpcWindowPresentationPrivate pdfpcWindowPresentationPrivate;

#define PDFPC_VIEW_TYPE_BASE (pdfpc_view_base_get_type ())
#define PDFPC_VIEW_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBase))
#define PDFPC_VIEW_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))
#define PDFPC_VIEW_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_BASE))
#define PDFPC_VIEW_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_BASE, pdfpcViewBaseClass))

typedef struct _pdfpcViewBase pdfpcViewBase;
typedef struct _pdfpcViewBaseClass pdfpcViewBaseClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PDFPC_METADATA_TYPE_BASE (pdfpc_metadata_base_get_type ())
#define PDFPC_METADATA_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBase))
#define PDFPC_METADATA_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))
#define PDFPC_METADATA_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))

typedef struct _pdfpcMetadataBase pdfpcMetadataBase;
typedef struct _pdfpcMetadataBaseClass pdfpcMetadataBaseClass;

#define PDFPC_METADATA_TYPE_PDF (pdfpc_metadata_pdf_get_type ())
#define PDFPC_METADATA_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdf))
#define PDFPC_METADATA_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))
#define PDFPC_METADATA_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))

typedef struct _pdfpcMetadataPdf pdfpcMetadataPdf;
typedef struct _pdfpcMetadataPdfClass pdfpcMetadataPdfClass;

#define PDFPC_VIEW_TYPE_DEFAULT (pdfpc_view_default_get_type ())
#define PDFPC_VIEW_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefault))
#define PDFPC_VIEW_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))
#define PDFPC_VIEW_IS_DEFAULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_IS_DEFAULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_DEFAULT))
#define PDFPC_VIEW_DEFAULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_DEFAULT, pdfpcViewDefaultClass))

typedef struct _pdfpcViewDefault pdfpcViewDefault;
typedef struct _pdfpcViewDefaultClass pdfpcViewDefaultClass;

#define PDFPC_VIEW_TYPE_PDF (pdfpc_view_pdf_get_type ())
#define PDFPC_VIEW_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdf))
#define PDFPC_VIEW_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdfClass))
#define PDFPC_VIEW_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_PDF))
#define PDFPC_VIEW_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_VIEW_TYPE_PDF))
#define PDFPC_VIEW_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_VIEW_TYPE_PDF, pdfpcViewPdfClass))

typedef struct _pdfpcViewPdf pdfpcViewPdf;
typedef struct _pdfpcViewPdfClass pdfpcViewPdfClass;

#define PDFPC_RENDERER_TYPE_BASE (pdfpc_renderer_base_get_type ())
#define PDFPC_RENDERER_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBase))
#define PDFPC_RENDERER_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))
#define PDFPC_RENDERER_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_TYPE_BASE))
#define PDFPC_RENDERER_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_TYPE_BASE, pdfpcRendererBaseClass))

typedef struct _pdfpcRendererBase pdfpcRendererBase;
typedef struct _pdfpcRendererBaseClass pdfpcRendererBaseClass;

#define PDFPC_RENDERER_TYPE_CACHING (pdfpc_renderer_caching_get_type ())
#define PDFPC_RENDERER_CACHING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_TYPE_CACHING, pdfpcRendererCaching))
#define PDFPC_RENDERER_IS_CACHING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_TYPE_CACHING))
#define PDFPC_RENDERER_CACHING_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_RENDERER_TYPE_CACHING, pdfpcRendererCachingIface))

typedef struct _pdfpcRendererCaching pdfpcRendererCaching;
typedef struct _pdfpcRendererCachingIface pdfpcRendererCachingIface;

#define PDFPC_RENDERER_CACHE_TYPE_BASE (pdfpc_renderer_cache_base_get_type ())
#define PDFPC_RENDERER_CACHE_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBase))
#define PDFPC_RENDERER_CACHE_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))
#define PDFPC_RENDERER_CACHE_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))

typedef struct _pdfpcRendererCacheBase pdfpcRendererCacheBase;
typedef struct _pdfpcRendererCacheBaseClass pdfpcRendererCacheBaseClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define PDFPC_TYPE_CACHE_STATUS (pdfpc_cache_status_get_type ())
#define PDFPC_CACHE_STATUS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_TYPE_CACHE_STATUS, pdfpcCacheStatus))
#define PDFPC_CACHE_STATUS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_TYPE_CACHE_STATUS, pdfpcCacheStatusClass))
#define PDFPC_IS_CACHE_STATUS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_TYPE_CACHE_STATUS))
#define PDFPC_IS_CACHE_STATUS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_TYPE_CACHE_STATUS))
#define PDFPC_CACHE_STATUS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_TYPE_CACHE_STATUS, pdfpcCacheStatusClass))

typedef struct _pdfpcCacheStatus pdfpcCacheStatus;
typedef struct _pdfpcCacheStatusClass pdfpcCacheStatusClass;

#define PDFPC_VIEW_TYPE_PRERENDERING (pdfpc_view_prerendering_get_type ())
#define PDFPC_VIEW_PRERENDERING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_VIEW_TYPE_PRERENDERING, pdfpcViewPrerendering))
#define PDFPC_VIEW_IS_PRERENDERING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_VIEW_TYPE_PRERENDERING))
#define PDFPC_VIEW_PRERENDERING_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PDFPC_VIEW_TYPE_PRERENDERING, pdfpcViewPrerenderingIface))

typedef struct _pdfpcViewPrerendering pdfpcViewPrerendering;
typedef struct _pdfpcViewPrerenderingIface pdfpcViewPrerenderingIface;

struct _pdfpcWindowFullscreen {
	GtkWindow parent_instance;
	pdfpcWindowFullscreenPrivate * priv;
	GdkRectangle screen_geometry;
	guint hide_cursor_timeout;
	gboolean faded_to_black;
	gboolean frozen;
};

struct _pdfpcWindowFullscreenClass {
	GtkWindowClass parent_class;
};

struct _pdfpcControllableIface {
	GTypeInterface parent_iface;
	pdfpcPresentationController* (*get_controller) (pdfpcControllable* self);
	void (*update) (pdfpcControllable* self);
	void (*edit_note) (pdfpcControllable* self);
	void (*ask_goto_page) (pdfpcControllable* self);
	void (*show_overview) (pdfpcControllable* self);
	void (*hide_overview) (pdfpcControllable* self);
};

struct _pdfpcWindowPresentation {
	pdfpcWindowFullscreen parent_instance;
	pdfpcWindowPresentationPrivate * priv;
	pdfpcPresentationController* presentation_controller;
	pdfpcViewBase* view;
};

struct _pdfpcWindowPresentationClass {
	pdfpcWindowFullscreenClass parent_class;
};

struct _pdfpcRendererCachingIface {
	GTypeInterface parent_iface;
	void (*set_cache) (pdfpcRendererCaching* self, pdfpcRendererCacheBase* cache);
	pdfpcRendererCacheBase* (*get_cache) (pdfpcRendererCaching* self);
};

typedef enum  {
	PDFPC_RENDERER_RENDER_ERROR_SLIDE_DOES_NOT_EXIST
} pdfpcRendererRenderError;
#define PDFPC_RENDERER_RENDER_ERROR pdfpc_renderer_render_error_quark ()
struct _pdfpcViewPrerenderingIface {
	GTypeInterface parent_iface;
};


static gpointer pdfpc_window_presentation_parent_class = NULL;
extern gboolean pdfpc_options_black_on_end;
extern gboolean pdfpc_options_disable_caching;
static pdfpcControllableIface* pdfpc_window_presentation_pdfpc_controllable_parent_iface = NULL;

GType pdfpc_window_fullscreen_get_type (void) G_GNUC_CONST;
GType pdfpc_presentation_controller_get_type (void) G_GNUC_CONST;
GType pdfpc_controllable_get_type (void) G_GNUC_CONST;
GType pdfpc_window_presentation_get_type (void) G_GNUC_CONST;
GType pdfpc_view_base_get_type (void) G_GNUC_CONST;
enum  {
	PDFPC_WINDOW_PRESENTATION_DUMMY_PROPERTY
};
GType pdfpc_metadata_base_get_type (void) G_GNUC_CONST;
GType pdfpc_metadata_pdf_get_type (void) G_GNUC_CONST;
pdfpcWindowPresentation* pdfpc_window_presentation_new (pdfpcMetadataPdf* metadata, gint screen_num, pdfpcPresentationController* presentation_controller);
pdfpcWindowPresentation* pdfpc_window_presentation_construct (GType object_type, pdfpcMetadataPdf* metadata, gint screen_num, pdfpcPresentationController* presentation_controller);
pdfpcWindowFullscreen* pdfpc_window_fullscreen_new (gint screen_num);
pdfpcWindowFullscreen* pdfpc_window_fullscreen_construct (GType object_type, gint screen_num);
static void __lambda10_ (pdfpcWindowPresentation* self, GtkObject* source);
static void ___lambda10__gtk_object_destroy (GtkObject* _sender, gpointer self);
gboolean pdfpc_presentation_controller_register_controllable (pdfpcPresentationController* self, pdfpcControllable* controllable);
GType pdfpc_view_default_get_type (void) G_GNUC_CONST;
GType pdfpc_view_pdf_get_type (void) G_GNUC_CONST;
pdfpcViewPdf* pdfpc_view_pdf_from_metadata (pdfpcMetadataPdf* metadata, gint width, gint height, gboolean allow_black_on_end, pdfpcPresentationController* presentation_controller, GdkRectangle* scale_rect);
GType pdfpc_renderer_base_get_type (void) G_GNUC_CONST;
pdfpcRendererBase* pdfpc_view_base_get_renderer (pdfpcViewBase* self);
GType pdfpc_renderer_cache_base_get_type (void) G_GNUC_CONST;
GType pdfpc_renderer_caching_get_type (void) G_GNUC_CONST;
void pdfpc_renderer_caching_set_cache (pdfpcRendererCaching* self, pdfpcRendererCacheBase* cache);
pdfpcRendererCacheBase* pdfpc_renderer_cache_option_factory_create (pdfpcMetadataBase* metadata);
gboolean pdfpc_window_presentation_on_key_pressed (pdfpcWindowPresentation* self, GdkEventKey* key);
static gboolean _pdfpc_window_presentation_on_key_pressed_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
gboolean pdfpc_window_presentation_on_button_press (pdfpcWindowPresentation* self, GdkEventButton* button);
static gboolean _pdfpc_window_presentation_on_button_press_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
gboolean pdfpc_window_presentation_on_scroll (pdfpcWindowPresentation* self, GtkWidget* source, GdkEventScroll* scroll);
static gboolean _pdfpc_window_presentation_on_scroll_gtk_widget_scroll_event (GtkWidget* _sender, GdkEventScroll* event, gpointer self);
gboolean pdfpc_presentation_controller_key_press (pdfpcPresentationController* self, GdkEventKey* key);
gboolean pdfpc_presentation_controller_button_press (pdfpcPresentationController* self, GdkEventButton* button);
void pdfpc_presentation_controller_scroll (pdfpcPresentationController* self, GdkEventScroll* scroll);
void pdfpc_window_presentation_set_controller (pdfpcWindowPresentation* self, pdfpcPresentationController* controller);
static pdfpcPresentationController* pdfpc_window_presentation_real_get_controller (pdfpcControllable* base);
static void pdfpc_window_presentation_real_update (pdfpcControllable* base);
gboolean pdfpc_presentation_controller_is_faded_to_black (pdfpcPresentationController* self);
void pdfpc_view_base_fade_to_black (pdfpcViewBase* self);
gboolean pdfpc_presentation_controller_is_frozen (pdfpcPresentationController* self);
GQuark pdfpc_renderer_render_error_quark (void);
void pdfpc_view_base_display (pdfpcViewBase* self, gint slide_number, gboolean force_redraw, GError** error);
gint pdfpc_presentation_controller_get_current_slide_number (pdfpcPresentationController* self);
static void pdfpc_window_presentation_real_edit_note (pdfpcControllable* base);
static void pdfpc_window_presentation_real_ask_goto_page (pdfpcControllable* base);
static void pdfpc_window_presentation_real_show_overview (pdfpcControllable* base);
static void pdfpc_window_presentation_real_hide_overview (pdfpcControllable* base);
gpointer pdfpc_cache_status_ref (gpointer instance);
void pdfpc_cache_status_unref (gpointer instance);
GParamSpec* pdfpc_param_spec_cache_status (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void pdfpc_value_set_cache_status (GValue* value, gpointer v_object);
void pdfpc_value_take_cache_status (GValue* value, gpointer v_object);
gpointer pdfpc_value_get_cache_status (const GValue* value);
GType pdfpc_cache_status_get_type (void) G_GNUC_CONST;
void pdfpc_window_presentation_set_cache_observer (pdfpcWindowPresentation* self, pdfpcCacheStatus* observer);
GType pdfpc_view_prerendering_get_type (void) G_GNUC_CONST;
void pdfpc_cache_status_monitor_view (pdfpcCacheStatus* self, pdfpcViewPrerendering* view);
static void pdfpc_window_presentation_finalize (GObject* obj);


/**
         * Base constructor instantiating a new presentation window
         */
static void __lambda10_ (pdfpcWindowPresentation* self, GtkObject* source) {
	g_return_if_fail (source != NULL);
	gtk_main_quit ();
}


static void ___lambda10__gtk_object_destroy (GtkObject* _sender, gpointer self) {
	__lambda10_ (self, _sender);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _pdfpc_window_presentation_on_key_pressed_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_presentation_on_key_pressed (self, event);
	return result;
}


static gboolean _pdfpc_window_presentation_on_button_press_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_presentation_on_button_press (self, event);
	return result;
}


static gboolean _pdfpc_window_presentation_on_scroll_gtk_widget_scroll_event (GtkWidget* _sender, GdkEventScroll* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_presentation_on_scroll (self, _sender, event);
	return result;
}


pdfpcWindowPresentation* pdfpc_window_presentation_construct (GType object_type, pdfpcMetadataPdf* metadata, gint screen_num, pdfpcPresentationController* presentation_controller) {
	pdfpcWindowPresentation * self = NULL;
	gint _tmp0_;
	pdfpcPresentationController* _tmp1_;
	pdfpcPresentationController* _tmp2_;
	pdfpcPresentationController* _tmp3_;
	GdkColor black = {0};
	GdkColor _tmp4_ = {0};
	GdkColor _tmp5_;
	GtkFixed* _tmp6_;
	GtkFixed* _tmp7_;
	GtkFixed* fixedLayout;
	GtkFixed* _tmp8_;
	GdkRectangle _tmp9_;
	gint _tmp10_;
	GdkRectangle _tmp11_;
	gint _tmp12_;
	GtkFixed* _tmp13_;
	GdkRectangle scale_rect = {0};
	pdfpcMetadataPdf* _tmp14_;
	GdkRectangle _tmp15_;
	gint _tmp16_;
	GdkRectangle _tmp17_;
	gint _tmp18_;
	gboolean _tmp19_;
	pdfpcPresentationController* _tmp20_;
	GdkRectangle _tmp21_ = {0};
	pdfpcViewPdf* _tmp22_ = NULL;
	gboolean _tmp23_;
	GtkFixed* _tmp30_;
	pdfpcViewBase* _tmp31_;
	GdkRectangle _tmp32_;
	gint _tmp33_;
	GdkRectangle _tmp34_;
	gint _tmp35_;
	g_return_val_if_fail (metadata != NULL, NULL);
	g_return_val_if_fail (presentation_controller != NULL, NULL);
	_tmp0_ = screen_num;
	self = (pdfpcWindowPresentation*) pdfpc_window_fullscreen_construct (object_type, _tmp0_);
	g_signal_connect_object ((GtkObject*) self, "destroy", (GCallback) ___lambda10__gtk_object_destroy, self, 0);
	_tmp1_ = presentation_controller;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->presentation_controller);
	self->presentation_controller = _tmp2_;
	_tmp3_ = self->presentation_controller;
	pdfpc_presentation_controller_register_controllable (_tmp3_, (pdfpcControllable*) self);
	gdk_color_parse ("black", &_tmp4_);
	black = _tmp4_;
	_tmp5_ = black;
	gtk_widget_modify_bg ((GtkWidget*) self, GTK_STATE_NORMAL, &_tmp5_);
	_tmp6_ = (GtkFixed*) gtk_fixed_new ();
	_tmp7_ = g_object_ref_sink (_tmp6_);
	fixedLayout = _tmp7_;
	_tmp8_ = fixedLayout;
	_tmp9_ = ((pdfpcWindowFullscreen*) self)->screen_geometry;
	_tmp10_ = _tmp9_.width;
	_tmp11_ = ((pdfpcWindowFullscreen*) self)->screen_geometry;
	_tmp12_ = _tmp11_.height;
	gtk_widget_set_size_request ((GtkWidget*) _tmp8_, _tmp10_, _tmp12_);
	_tmp13_ = fixedLayout;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp13_);
	_tmp14_ = metadata;
	_tmp15_ = ((pdfpcWindowFullscreen*) self)->screen_geometry;
	_tmp16_ = _tmp15_.width;
	_tmp17_ = ((pdfpcWindowFullscreen*) self)->screen_geometry;
	_tmp18_ = _tmp17_.height;
	_tmp19_ = pdfpc_options_black_on_end;
	_tmp20_ = self->presentation_controller;
	_tmp22_ = pdfpc_view_pdf_from_metadata (_tmp14_, _tmp16_, _tmp18_, _tmp19_, _tmp20_, &_tmp21_);
	scale_rect = _tmp21_;
	_g_object_unref0 (self->view);
	self->view = (pdfpcViewBase*) _tmp22_;
	_tmp23_ = pdfpc_options_disable_caching;
	if (!_tmp23_) {
		pdfpcViewBase* _tmp24_;
		pdfpcRendererBase* _tmp25_ = NULL;
		pdfpcRendererCaching* _tmp26_;
		pdfpcMetadataPdf* _tmp27_;
		pdfpcRendererCacheBase* _tmp28_ = NULL;
		pdfpcRendererCacheBase* _tmp29_;
		_tmp24_ = self->view;
		_tmp25_ = pdfpc_view_base_get_renderer (_tmp24_);
		_tmp26_ = PDFPC_RENDERER_CACHING (_tmp25_);
		_tmp27_ = metadata;
		_tmp28_ = pdfpc_renderer_cache_option_factory_create ((pdfpcMetadataBase*) _tmp27_);
		_tmp29_ = _tmp28_;
		pdfpc_renderer_caching_set_cache (_tmp26_, _tmp29_);
		_g_object_unref0 (_tmp29_);
		_g_object_unref0 (_tmp26_);
	}
	_tmp30_ = fixedLayout;
	_tmp31_ = self->view;
	_tmp32_ = scale_rect;
	_tmp33_ = _tmp32_.x;
	_tmp34_ = scale_rect;
	_tmp35_ = _tmp34_.y;
	gtk_fixed_put (_tmp30_, (GtkWidget*) _tmp31_, _tmp33_, _tmp35_);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_KEY_PRESS_MASK);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_BUTTON_PRESS_MASK);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_SCROLL_MASK);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _pdfpc_window_presentation_on_key_pressed_gtk_widget_key_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) _pdfpc_window_presentation_on_button_press_gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "scroll-event", (GCallback) _pdfpc_window_presentation_on_scroll_gtk_widget_scroll_event, self, 0);
	_g_object_unref0 (fixedLayout);
	return self;
}


pdfpcWindowPresentation* pdfpc_window_presentation_new (pdfpcMetadataPdf* metadata, gint screen_num, pdfpcPresentationController* presentation_controller) {
	return pdfpc_window_presentation_construct (PDFPC_WINDOW_TYPE_PRESENTATION, metadata, screen_num, presentation_controller);
}


/**
         * Handle keypress vents on the window and, if neccessary send them to the
         * presentation controller
         */
gboolean pdfpc_window_presentation_on_key_pressed (pdfpcWindowPresentation* self, GdkEventKey* key) {
	gboolean result = FALSE;
	pdfpcPresentationController* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = self->presentation_controller;
	if (_tmp0_ != NULL) {
		pdfpcPresentationController* _tmp1_;
		GdkEventKey _tmp2_;
		_tmp1_ = self->presentation_controller;
		_tmp2_ = *key;
		pdfpc_presentation_controller_key_press (_tmp1_, &_tmp2_);
	}
	result = FALSE;
	return result;
}


/**
         * Handle mouse button events on the window and, if neccessary send
         * them to the presentation controller
         */
gboolean pdfpc_window_presentation_on_button_press (pdfpcWindowPresentation* self, GdkEventButton* button) {
	gboolean result = FALSE;
	pdfpcPresentationController* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (button != NULL, FALSE);
	_tmp0_ = self->presentation_controller;
	if (_tmp0_ != NULL) {
		pdfpcPresentationController* _tmp1_;
		GdkEventButton _tmp2_;
		_tmp1_ = self->presentation_controller;
		_tmp2_ = *button;
		pdfpc_presentation_controller_button_press (_tmp1_, &_tmp2_);
	}
	result = FALSE;
	return result;
}


/**
         * Handle mouse scrolling events on the window and, if neccessary send
         * them to the presentation controller
         */
gboolean pdfpc_window_presentation_on_scroll (pdfpcWindowPresentation* self, GtkWidget* source, GdkEventScroll* scroll) {
	gboolean result = FALSE;
	pdfpcPresentationController* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (scroll != NULL, FALSE);
	_tmp0_ = self->presentation_controller;
	if (_tmp0_ != NULL) {
		pdfpcPresentationController* _tmp1_;
		GdkEventScroll _tmp2_;
		_tmp1_ = self->presentation_controller;
		_tmp2_ = *scroll;
		pdfpc_presentation_controller_scroll (_tmp1_, &_tmp2_);
	}
	result = FALSE;
	return result;
}


/**
         * Set the presentation controller which is notified of keypresses and
         * other observed events
         */
void pdfpc_window_presentation_set_controller (pdfpcWindowPresentation* self, pdfpcPresentationController* controller) {
	pdfpcPresentationController* _tmp0_;
	pdfpcPresentationController* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (controller != NULL);
	_tmp0_ = controller;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->presentation_controller);
	self->presentation_controller = _tmp1_;
}


/**
         * Return the PresentationController
         */
static pdfpcPresentationController* pdfpc_window_presentation_real_get_controller (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	pdfpcPresentationController* result = NULL;
	pdfpcPresentationController* _tmp0_;
	pdfpcPresentationController* _tmp1_;
	self = (pdfpcWindowPresentation*) base;
	_tmp0_ = self->presentation_controller;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


/**
         * Update the display
         */
static void pdfpc_window_presentation_real_update (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	pdfpcPresentationController* _tmp0_;
	gboolean _tmp1_ = FALSE;
	pdfpcPresentationController* _tmp3_;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (pdfpcWindowPresentation*) base;
	_tmp0_ = self->presentation_controller;
	_tmp1_ = pdfpc_presentation_controller_is_faded_to_black (_tmp0_);
	if (_tmp1_) {
		pdfpcViewBase* _tmp2_;
		_tmp2_ = self->view;
		pdfpc_view_base_fade_to_black (_tmp2_);
		return;
	}
	_tmp3_ = self->presentation_controller;
	_tmp4_ = pdfpc_presentation_controller_is_frozen (_tmp3_);
	if (_tmp4_) {
		return;
	}
	{
		pdfpcViewBase* _tmp5_;
		pdfpcPresentationController* _tmp6_;
		gint _tmp7_ = 0;
		_tmp5_ = self->view;
		_tmp6_ = self->presentation_controller;
		_tmp7_ = pdfpc_presentation_controller_get_current_slide_number (_tmp6_);
		pdfpc_view_base_display (_tmp5_, _tmp7_, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == PDFPC_RENDERER_RENDER_ERROR) {
				goto __catch9_pdfpc_renderer_render_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally9;
	__catch9_pdfpc_renderer_render_error:
	{
		GError* e = NULL;
		pdfpcPresentationController* _tmp8_;
		gint _tmp9_ = 0;
		const gchar* _tmp10_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = self->presentation_controller;
		_tmp9_ = pdfpc_presentation_controller_get_current_slide_number (_tmp8_);
		_tmp10_ = e->message;
		g_error ("presentation.vala:163: The pdf page %d could not be rendered: %s", _tmp9_, _tmp10_);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


/**
         * Edit note for current slide. We don't do anything.
         */
static void pdfpc_window_presentation_real_edit_note (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	self = (pdfpcWindowPresentation*) base;
}


/**
         * Ask for the page to jump to. We don't do anything
         */
static void pdfpc_window_presentation_real_ask_goto_page (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	self = (pdfpcWindowPresentation*) base;
}


/**
         * Show an overview. We don't do anything (yet?)
         */
static void pdfpc_window_presentation_real_show_overview (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	self = (pdfpcWindowPresentation*) base;
}


/**
         * Hide the overview. We don't do anything
         */
static void pdfpc_window_presentation_real_hide_overview (pdfpcControllable* base) {
	pdfpcWindowPresentation * self;
	self = (pdfpcWindowPresentation*) base;
}


/**
         * Set the cache observer for the Views on this window
         *
         * This method takes care of registering all Prerendering Views used by
         * this window correctly with the CacheStatus object to provide acurate
         * cache status measurements.
         */
void pdfpc_window_presentation_set_cache_observer (pdfpcWindowPresentation* self, pdfpcCacheStatus* observer) {
	pdfpcViewBase* _tmp0_;
	pdfpcViewPrerendering* _tmp1_;
	pdfpcViewPrerendering* prerendering_view;
	pdfpcViewPrerendering* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (observer != NULL);
	_tmp0_ = self->view;
	_tmp1_ = _g_object_ref0 (PDFPC_VIEW_IS_PRERENDERING (_tmp0_) ? ((pdfpcViewPrerendering*) _tmp0_) : NULL);
	prerendering_view = _tmp1_;
	_tmp2_ = prerendering_view;
	if (_tmp2_ != NULL) {
		pdfpcCacheStatus* _tmp3_;
		pdfpcViewPrerendering* _tmp4_;
		_tmp3_ = observer;
		_tmp4_ = prerendering_view;
		pdfpc_cache_status_monitor_view (_tmp3_, _tmp4_);
	}
	_g_object_unref0 (prerendering_view);
}


static void pdfpc_window_presentation_class_init (pdfpcWindowPresentationClass * klass) {
	pdfpc_window_presentation_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = pdfpc_window_presentation_finalize;
}


static void pdfpc_window_presentation_pdfpc_controllable_interface_init (pdfpcControllableIface * iface) {
	pdfpc_window_presentation_pdfpc_controllable_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_controller = (pdfpcPresentationController* (*)(pdfpcControllable*)) pdfpc_window_presentation_real_get_controller;
	iface->update = (void (*)(pdfpcControllable*)) pdfpc_window_presentation_real_update;
	iface->edit_note = (void (*)(pdfpcControllable*)) pdfpc_window_presentation_real_edit_note;
	iface->ask_goto_page = (void (*)(pdfpcControllable*)) pdfpc_window_presentation_real_ask_goto_page;
	iface->show_overview = (void (*)(pdfpcControllable*)) pdfpc_window_presentation_real_show_overview;
	iface->hide_overview = (void (*)(pdfpcControllable*)) pdfpc_window_presentation_real_hide_overview;
}


static void pdfpc_window_presentation_instance_init (pdfpcWindowPresentation * self) {
	self->presentation_controller = NULL;
}


static void pdfpc_window_presentation_finalize (GObject* obj) {
	pdfpcWindowPresentation * self;
	self = PDFPC_WINDOW_PRESENTATION (obj);
	_g_object_unref0 (self->presentation_controller);
	_g_object_unref0 (self->view);
	G_OBJECT_CLASS (pdfpc_window_presentation_parent_class)->finalize (obj);
}


/**
     * Window showing the currently active slide to be presented on a beamer
     */
GType pdfpc_window_presentation_get_type (void) {
	static volatile gsize pdfpc_window_presentation_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_window_presentation_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcWindowPresentationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_window_presentation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcWindowPresentation), 0, (GInstanceInitFunc) pdfpc_window_presentation_instance_init, NULL };
		static const GInterfaceInfo pdfpc_controllable_info = { (GInterfaceInitFunc) pdfpc_window_presentation_pdfpc_controllable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType pdfpc_window_presentation_type_id;
		pdfpc_window_presentation_type_id = g_type_register_static (PDFPC_WINDOW_TYPE_FULLSCREEN, "pdfpcWindowPresentation", &g_define_type_info, 0);
		g_type_add_interface_static (pdfpc_window_presentation_type_id, PDFPC_TYPE_CONTROLLABLE, &pdfpc_controllable_info);
		g_once_init_leave (&pdfpc_window_presentation_type_id__volatile, pdfpc_window_presentation_type_id);
	}
	return pdfpc_window_presentation_type_id__volatile;
}



