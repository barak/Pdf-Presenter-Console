/* fullscreen.c generated by valac 0.16.0, the Vala compiler
 * generated from fullscreen.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>


#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN (org_westhoffswelt_pdfpresenter_window_fullscreen_get_type ())
#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN, orgwesthoffsweltpdfpresenterWindowFullscreen))
#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN, orgwesthoffsweltpdfpresenterWindowFullscreenClass))
#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_IS_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN))
#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_IS_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN))
#define ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_FULLSCREEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN, orgwesthoffsweltpdfpresenterWindowFullscreenClass))

typedef struct _orgwesthoffsweltpdfpresenterWindowFullscreen orgwesthoffsweltpdfpresenterWindowFullscreen;
typedef struct _orgwesthoffsweltpdfpresenterWindowFullscreenClass orgwesthoffsweltpdfpresenterWindowFullscreenClass;
typedef struct _orgwesthoffsweltpdfpresenterWindowFullscreenPrivate orgwesthoffsweltpdfpresenterWindowFullscreenPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gdk_cursor_unref0(var) ((var == NULL) ? NULL : (var = (gdk_cursor_unref (var), NULL)))

struct _orgwesthoffsweltpdfpresenterWindowFullscreen {
	GtkWindow parent_instance;
	orgwesthoffsweltpdfpresenterWindowFullscreenPrivate * priv;
	GdkRectangle screen_geometry;
	guint hide_cursor_timeout;
	gboolean faded_to_black;
	gboolean frozen;
};

struct _orgwesthoffsweltpdfpresenterWindowFullscreenClass {
	GtkWindowClass parent_class;
};


static gpointer org_westhoffswelt_pdfpresenter_window_fullscreen_parent_class = NULL;

GType org_westhoffswelt_pdfpresenter_window_fullscreen_get_type (void) G_GNUC_CONST;
enum  {
	ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_FULLSCREEN_DUMMY_PROPERTY
};
orgwesthoffsweltpdfpresenterWindowFullscreen* org_westhoffswelt_pdfpresenter_window_fullscreen_new (gint screen_num);
orgwesthoffsweltpdfpresenterWindowFullscreen* org_westhoffswelt_pdfpresenter_window_fullscreen_construct (GType object_type, gint screen_num);
void org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate (orgwesthoffsweltpdfpresenterWindowFullscreen* self, GtkWidget* source, GdkRectangle* r);
static void _org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self);
gboolean org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move (orgwesthoffsweltpdfpresenterWindowFullscreen* self, GtkWidget* source, GdkEventMotion* event);
static gboolean _org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
void org_westhoffswelt_pdfpresenter_window_fullscreen_restart_hide_cursor_timer (orgwesthoffsweltpdfpresenterWindowFullscreen* self);
gboolean org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout (orgwesthoffsweltpdfpresenterWindowFullscreen* self);
static gboolean _org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout_gsource_func (gpointer self);
static void org_westhoffswelt_pdfpresenter_window_fullscreen_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self) {
	org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate (self, _sender, allocation);
}


static gboolean _org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move (self, _sender, event);
	return result;
}


orgwesthoffsweltpdfpresenterWindowFullscreen* org_westhoffswelt_pdfpresenter_window_fullscreen_construct (GType object_type, gint screen_num) {
	orgwesthoffsweltpdfpresenterWindowFullscreen * self = NULL;
	GdkScreen* screen = NULL;
	gint _tmp0_;
	GdkRectangle _tmp20_;
	gint _tmp21_;
	GdkRectangle _tmp22_;
	gint _tmp23_;
	self = (orgwesthoffsweltpdfpresenterWindowFullscreen*) g_object_new (object_type, NULL);
	_tmp0_ = screen_num;
	if (_tmp0_ >= 0) {
		GdkScreen* _tmp1_ = NULL;
		GdkScreen* _tmp2_;
		GdkScreen* _tmp3_;
		gint _tmp4_;
		GdkRectangle _tmp5_ = {0};
		_tmp1_ = gdk_screen_get_default ();
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (screen);
		screen = _tmp2_;
		_tmp3_ = screen;
		_tmp4_ = screen_num;
		gdk_screen_get_monitor_geometry (_tmp3_, _tmp4_, &_tmp5_);
		self->screen_geometry = _tmp5_;
	} else {
		GdkDisplay* _tmp6_ = NULL;
		GdkDisplay* _tmp7_;
		GdkDisplay* display;
		gint pointerx = 0;
		gint pointery = 0;
		GdkDisplay* _tmp8_;
		GdkScreen* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		GdkScreen* _tmp12_;
		GdkScreen* _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		gint _tmp16_ = 0;
		gint current_screen;
		GdkScreen* _tmp17_;
		gint _tmp18_;
		GdkRectangle _tmp19_ = {0};
		_tmp6_ = gdk_display_get_default ();
		_tmp7_ = _g_object_ref0 (_tmp6_);
		display = _tmp7_;
		_tmp8_ = display;
		gdk_display_get_pointer (_tmp8_, &_tmp9_, &_tmp10_, &_tmp11_, NULL);
		_g_object_unref0 (screen);
		_tmp12_ = _g_object_ref0 (_tmp9_);
		screen = _tmp12_;
		pointerx = _tmp10_;
		pointery = _tmp11_;
		_tmp13_ = screen;
		_tmp14_ = pointerx;
		_tmp15_ = pointery;
		_tmp16_ = gdk_screen_get_monitor_at_point (_tmp13_, _tmp14_, _tmp15_);
		current_screen = _tmp16_;
		_tmp17_ = screen;
		_tmp18_ = current_screen;
		gdk_screen_get_monitor_geometry (_tmp17_, _tmp18_, &_tmp19_);
		self->screen_geometry = _tmp19_;
		_g_object_unref0 (display);
	}
	_tmp20_ = self->screen_geometry;
	_tmp21_ = _tmp20_.x;
	_tmp22_ = self->screen_geometry;
	_tmp23_ = _tmp22_.y;
	gtk_window_move ((GtkWindow*) self, _tmp21_, _tmp23_);
	gtk_window_fullscreen ((GtkWindow*) self);
	g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) _org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate_gtk_widget_size_allocate, self, 0);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_POINTER_MOTION_MASK);
	g_signal_connect_object ((GtkWidget*) self, "motion-notify-event", (GCallback) _org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event, self, 0);
	org_westhoffswelt_pdfpresenter_window_fullscreen_restart_hide_cursor_timer (self);
	_g_object_unref0 (screen);
	return self;
}


orgwesthoffsweltpdfpresenterWindowFullscreen* org_westhoffswelt_pdfpresenter_window_fullscreen_new (gint screen_num) {
	return org_westhoffswelt_pdfpresenter_window_fullscreen_construct (ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_TYPE_FULLSCREEN, screen_num);
}


/**
         * Called if window size is allocated
         *
         * This method is needed, because certain window manager (eg. Xfwm4) ignore
         * movement commands before the window has been displayed for the first
         * time.
         */
void org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate (orgwesthoffsweltpdfpresenterWindowFullscreen* self, GtkWidget* source, GdkRectangle* r) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	g_return_if_fail (r != NULL);
	_tmp0_ = GTK_WIDGET_MAPPED ((GtkWidget*) self);
	if (_tmp0_) {
		guint _tmp1_ = 0U;
		gint x = 0;
		gint y = 0;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		gboolean _tmp4_ = FALSE;
		gint _tmp5_;
		GdkRectangle _tmp6_;
		gint _tmp7_;
		gboolean _tmp11_;
		GdkRectangle _tmp12_;
		gint _tmp13_;
		GdkRectangle _tmp14_;
		gint _tmp15_;
		GdkRectangle _tmp16_;
		gint _tmp17_;
		GdkRectangle _tmp18_;
		gint _tmp19_;
		g_signal_parse_name ("size-allocate", GTK_TYPE_WIDGET, &_tmp1_, NULL, FALSE);
		g_signal_handlers_disconnect_matched ((GtkWidget*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _org_westhoffswelt_pdfpresenter_window_fullscreen_on_size_allocate_gtk_widget_size_allocate, self);
		gtk_window_get_position ((GtkWindow*) self, &_tmp2_, &_tmp3_);
		x = _tmp2_;
		y = _tmp3_;
		_tmp5_ = x;
		_tmp6_ = self->screen_geometry;
		_tmp7_ = _tmp6_.x;
		if (_tmp5_ == _tmp7_) {
			gint _tmp8_;
			GdkRectangle _tmp9_;
			gint _tmp10_;
			_tmp8_ = y;
			_tmp9_ = self->screen_geometry;
			_tmp10_ = _tmp9_.y;
			_tmp4_ = _tmp8_ == _tmp10_;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp11_ = _tmp4_;
		if (_tmp11_) {
			return;
		}
		gtk_window_unfullscreen ((GtkWindow*) self);
		gtk_window_unmaximize ((GtkWindow*) self);
		_tmp12_ = self->screen_geometry;
		_tmp13_ = _tmp12_.x;
		_tmp14_ = self->screen_geometry;
		_tmp15_ = _tmp14_.y;
		gtk_window_move ((GtkWindow*) self, _tmp13_, _tmp15_);
		_tmp16_ = self->screen_geometry;
		_tmp17_ = _tmp16_.width;
		_tmp18_ = self->screen_geometry;
		_tmp19_ = _tmp18_.height;
		gtk_window_resize ((GtkWindow*) self, _tmp17_, _tmp19_);
		gtk_window_fullscreen ((GtkWindow*) self);
	}
}


/**
         * Called every time the mouse cursor is moved
         */
gboolean org_westhoffswelt_pdfpresenter_window_fullscreen_on_mouse_move (orgwesthoffsweltpdfpresenterWindowFullscreen* self, GtkWidget* source, GdkEventMotion* event) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = ((GtkWidget*) self)->window;
	gdk_window_set_cursor (_tmp0_, NULL);
	org_westhoffswelt_pdfpresenter_window_fullscreen_restart_hide_cursor_timer (self);
	result = FALSE;
	return result;
}


/**
         * Restart the 5 seconds timeout before hiding the mouse cursor
         */
static gboolean _org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout_gsource_func (gpointer self) {
	gboolean result;
	result = org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout (self);
	return result;
}


void org_westhoffswelt_pdfpresenter_window_fullscreen_restart_hide_cursor_timer (orgwesthoffsweltpdfpresenterWindowFullscreen* self) {
	guint _tmp0_;
	guint _tmp2_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->hide_cursor_timeout;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->hide_cursor_timeout;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 5, _org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout_gsource_func, g_object_ref (self), g_object_unref);
	self->hide_cursor_timeout = _tmp2_;
}


/**
         * Timeout method called if the mouse pointer has not been moved for 5
         * seconds
         */
gboolean org_westhoffswelt_pdfpresenter_window_fullscreen_on_hide_cursor_timeout (orgwesthoffsweltpdfpresenterWindowFullscreen* self) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	self->hide_cursor_timeout = (guint) 0;
	_tmp0_ = ((GtkWidget*) self)->window;
	if (_tmp0_ != NULL) {
		GdkWindow* _tmp1_;
		GdkCursor* _tmp2_;
		GdkCursor* _tmp3_;
		_tmp1_ = ((GtkWidget*) self)->window;
		_tmp2_ = gdk_cursor_new (GDK_BLANK_CURSOR);
		_tmp3_ = _tmp2_;
		gdk_window_set_cursor (_tmp1_, _tmp3_);
		_gdk_cursor_unref0 (_tmp3_);
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}


static void org_westhoffswelt_pdfpresenter_window_fullscreen_class_init (orgwesthoffsweltpdfpresenterWindowFullscreenClass * klass) {
	org_westhoffswelt_pdfpresenter_window_fullscreen_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = org_westhoffswelt_pdfpresenter_window_fullscreen_finalize;
}


static void org_westhoffswelt_pdfpresenter_window_fullscreen_instance_init (orgwesthoffsweltpdfpresenterWindowFullscreen * self) {
	self->hide_cursor_timeout = (guint) 0;
	self->faded_to_black = FALSE;
	self->frozen = FALSE;
}


static void org_westhoffswelt_pdfpresenter_window_fullscreen_finalize (GObject* obj) {
	orgwesthoffsweltpdfpresenterWindowFullscreen * self;
	self = ORG_WESTHOFFSWELT_PDFPRESENTER_WINDOW_FULLSCREEN (obj);
	G_OBJECT_CLASS (org_westhoffswelt_pdfpresenter_window_fullscreen_parent_class)->finalize (obj);
}


/**
     * Window extension implementing all the needed functionality, to be
     * displayed fullscreen.
     *
     * Methods to specify the monitor to be displayed on in a multi-head setup
     * are provided as well.
     */
GType org_westhoffswelt_pdfpresenter_window_fullscreen_get_type (void) {
	static volatile gsize org_westhoffswelt_pdfpresenter_window_fullscreen_type_id__volatile = 0;
	if (g_once_init_enter (&org_westhoffswelt_pdfpresenter_window_fullscreen_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (orgwesthoffsweltpdfpresenterWindowFullscreenClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) org_westhoffswelt_pdfpresenter_window_fullscreen_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (orgwesthoffsweltpdfpresenterWindowFullscreen), 0, (GInstanceInitFunc) org_westhoffswelt_pdfpresenter_window_fullscreen_instance_init, NULL };
		GType org_westhoffswelt_pdfpresenter_window_fullscreen_type_id;
		org_westhoffswelt_pdfpresenter_window_fullscreen_type_id = g_type_register_static (GTK_TYPE_WINDOW, "orgwesthoffsweltpdfpresenterWindowFullscreen", &g_define_type_info, 0);
		g_once_init_leave (&org_westhoffswelt_pdfpresenter_window_fullscreen_type_id__volatile, org_westhoffswelt_pdfpresenter_window_fullscreen_type_id);
	}
	return org_westhoffswelt_pdfpresenter_window_fullscreen_type_id__volatile;
}



