/* fullscreen.c generated by valac 0.16.0, the Vala compiler
 * generated from fullscreen.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>


#define PDFPC_WINDOW_TYPE_FULLSCREEN (pdfpc_window_fullscreen_get_type ())
#define PDFPC_WINDOW_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreen))
#define PDFPC_WINDOW_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))
#define PDFPC_WINDOW_IS_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_IS_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_FULLSCREEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))

typedef struct _pdfpcWindowFullscreen pdfpcWindowFullscreen;
typedef struct _pdfpcWindowFullscreenClass pdfpcWindowFullscreenClass;
typedef struct _pdfpcWindowFullscreenPrivate pdfpcWindowFullscreenPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gdk_cursor_unref0(var) ((var == NULL) ? NULL : (var = (gdk_cursor_unref (var), NULL)))

struct _pdfpcWindowFullscreen {
	GtkWindow parent_instance;
	pdfpcWindowFullscreenPrivate * priv;
	GdkRectangle screen_geometry;
	guint hide_cursor_timeout;
	gboolean faded_to_black;
	gboolean frozen;
};

struct _pdfpcWindowFullscreenClass {
	GtkWindowClass parent_class;
};


static gpointer pdfpc_window_fullscreen_parent_class = NULL;
extern gboolean pdfpc_options_windowed;

GType pdfpc_window_fullscreen_get_type (void) G_GNUC_CONST;
enum  {
	PDFPC_WINDOW_FULLSCREEN_DUMMY_PROPERTY
};
pdfpcWindowFullscreen* pdfpc_window_fullscreen_new (gint screen_num);
pdfpcWindowFullscreen* pdfpc_window_fullscreen_construct (GType object_type, gint screen_num);
void pdfpc_window_fullscreen_on_size_allocate (pdfpcWindowFullscreen* self, GtkWidget* source, GdkRectangle* r);
static void _pdfpc_window_fullscreen_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self);
gboolean pdfpc_window_fullscreen_on_configure (pdfpcWindowFullscreen* self, GdkEventConfigure* e);
static gboolean _pdfpc_window_fullscreen_on_configure_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
gboolean pdfpc_window_fullscreen_on_mouse_move (pdfpcWindowFullscreen* self, GtkWidget* source, GdkEventMotion* event);
static gboolean _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
void pdfpc_window_fullscreen_restart_hide_cursor_timer (pdfpcWindowFullscreen* self);
gboolean pdfpc_window_fullscreen_on_hide_cursor_timeout (pdfpcWindowFullscreen* self);
static gboolean _pdfpc_window_fullscreen_on_hide_cursor_timeout_gsource_func (gpointer self);
static void pdfpc_window_fullscreen_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _pdfpc_window_fullscreen_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self) {
	pdfpc_window_fullscreen_on_size_allocate (self, _sender, allocation);
}


static gboolean _pdfpc_window_fullscreen_on_configure_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_fullscreen_on_configure (self, event);
	return result;
}


static gboolean _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_fullscreen_on_mouse_move (self, _sender, event);
	return result;
}


pdfpcWindowFullscreen* pdfpc_window_fullscreen_construct (GType object_type, gint screen_num) {
	pdfpcWindowFullscreen * self = NULL;
	GdkScreen* screen = NULL;
	gint _tmp0_;
	gboolean _tmp20_;
	self = (pdfpcWindowFullscreen*) g_object_new (object_type, NULL);
	_tmp0_ = screen_num;
	if (_tmp0_ >= 0) {
		GdkScreen* _tmp1_ = NULL;
		GdkScreen* _tmp2_;
		GdkScreen* _tmp3_;
		gint _tmp4_;
		GdkRectangle _tmp5_ = {0};
		_tmp1_ = gdk_screen_get_default ();
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (screen);
		screen = _tmp2_;
		_tmp3_ = screen;
		_tmp4_ = screen_num;
		gdk_screen_get_monitor_geometry (_tmp3_, _tmp4_, &_tmp5_);
		self->screen_geometry = _tmp5_;
	} else {
		GdkDisplay* _tmp6_ = NULL;
		GdkDisplay* _tmp7_;
		GdkDisplay* display;
		gint pointerx = 0;
		gint pointery = 0;
		GdkDisplay* _tmp8_;
		GdkScreen* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		GdkScreen* _tmp12_;
		GdkScreen* _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		gint _tmp16_ = 0;
		gint current_screen;
		GdkScreen* _tmp17_;
		gint _tmp18_;
		GdkRectangle _tmp19_ = {0};
		_tmp6_ = gdk_display_get_default ();
		_tmp7_ = _g_object_ref0 (_tmp6_);
		display = _tmp7_;
		_tmp8_ = display;
		gdk_display_get_pointer (_tmp8_, &_tmp9_, &_tmp10_, &_tmp11_, NULL);
		_g_object_unref0 (screen);
		_tmp12_ = _g_object_ref0 (_tmp9_);
		screen = _tmp12_;
		pointerx = _tmp10_;
		pointery = _tmp11_;
		_tmp13_ = screen;
		_tmp14_ = pointerx;
		_tmp15_ = pointery;
		_tmp16_ = gdk_screen_get_monitor_at_point (_tmp13_, _tmp14_, _tmp15_);
		current_screen = _tmp16_;
		_tmp17_ = screen;
		_tmp18_ = current_screen;
		gdk_screen_get_monitor_geometry (_tmp17_, _tmp18_, &_tmp19_);
		self->screen_geometry = _tmp19_;
		_g_object_unref0 (display);
	}
	_tmp20_ = pdfpc_options_windowed;
	if (!_tmp20_) {
		GdkRectangle _tmp21_;
		gint _tmp22_;
		GdkRectangle _tmp23_;
		gint _tmp24_;
		_tmp21_ = self->screen_geometry;
		_tmp22_ = _tmp21_.x;
		_tmp23_ = self->screen_geometry;
		_tmp24_ = _tmp23_.y;
		gtk_window_move ((GtkWindow*) self, _tmp22_, _tmp24_);
		g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) _pdfpc_window_fullscreen_on_size_allocate_gtk_widget_size_allocate, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "configure-event", (GCallback) _pdfpc_window_fullscreen_on_configure_gtk_widget_configure_event, self, 0);
	} else {
		gint _tmp25_;
		gint _tmp26_;
		_tmp25_ = self->screen_geometry.width;
		self->screen_geometry.width = _tmp25_ / 2;
		_tmp26_ = self->screen_geometry.height;
		self->screen_geometry.height = _tmp26_ / 2;
		gtk_window_set_resizable ((GtkWindow*) self, FALSE);
	}
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_POINTER_MOTION_MASK);
	g_signal_connect_object ((GtkWidget*) self, "motion-notify-event", (GCallback) _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event, self, 0);
	pdfpc_window_fullscreen_restart_hide_cursor_timer (self);
	_g_object_unref0 (screen);
	return self;
}


pdfpcWindowFullscreen* pdfpc_window_fullscreen_new (gint screen_num) {
	return pdfpc_window_fullscreen_construct (PDFPC_WINDOW_TYPE_FULLSCREEN, screen_num);
}


gboolean pdfpc_window_fullscreen_on_configure (pdfpcWindowFullscreen* self, GdkEventConfigure* e) {
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	gtk_window_fullscreen ((GtkWindow*) self);
	g_signal_parse_name ("configure-event", GTK_TYPE_WIDGET, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GtkWidget*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _pdfpc_window_fullscreen_on_configure_gtk_widget_configure_event, self);
	result = FALSE;
	return result;
}


/**
         * Called if window size is allocated
         *
         * This method is needed, because certain window manager (eg. Xfwm4) ignore
         * movement commands before the window has been displayed for the first
         * time.
         */
void pdfpc_window_fullscreen_on_size_allocate (pdfpcWindowFullscreen* self, GtkWidget* source, GdkRectangle* r) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	g_return_if_fail (r != NULL);
	_tmp0_ = GTK_WIDGET_MAPPED ((GtkWidget*) self);
	if (_tmp0_) {
		guint _tmp1_ = 0U;
		gint x = 0;
		gint y = 0;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		gboolean _tmp4_ = FALSE;
		gint _tmp5_;
		GdkRectangle _tmp6_;
		gint _tmp7_;
		gboolean _tmp11_;
		GdkRectangle _tmp12_;
		gint _tmp13_;
		GdkRectangle _tmp14_;
		gint _tmp15_;
		g_signal_parse_name ("size-allocate", GTK_TYPE_WIDGET, &_tmp1_, NULL, FALSE);
		g_signal_handlers_disconnect_matched ((GtkWidget*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _pdfpc_window_fullscreen_on_size_allocate_gtk_widget_size_allocate, self);
		gtk_window_get_position ((GtkWindow*) self, &_tmp2_, &_tmp3_);
		x = _tmp2_;
		y = _tmp3_;
		_tmp5_ = x;
		_tmp6_ = self->screen_geometry;
		_tmp7_ = _tmp6_.x;
		if (_tmp5_ == _tmp7_) {
			gint _tmp8_;
			GdkRectangle _tmp9_;
			gint _tmp10_;
			_tmp8_ = y;
			_tmp9_ = self->screen_geometry;
			_tmp10_ = _tmp9_.y;
			_tmp4_ = _tmp8_ == _tmp10_;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp11_ = _tmp4_;
		if (_tmp11_) {
			return;
		}
		_tmp12_ = self->screen_geometry;
		_tmp13_ = _tmp12_.x;
		_tmp14_ = self->screen_geometry;
		_tmp15_ = _tmp14_.y;
		gtk_window_move ((GtkWindow*) self, _tmp13_, _tmp15_);
		gtk_window_fullscreen ((GtkWindow*) self);
	}
}


/**
         * Called every time the mouse cursor is moved
         */
gboolean pdfpc_window_fullscreen_on_mouse_move (pdfpcWindowFullscreen* self, GtkWidget* source, GdkEventMotion* event) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = ((GtkWidget*) self)->window;
	gdk_window_set_cursor (_tmp0_, NULL);
	pdfpc_window_fullscreen_restart_hide_cursor_timer (self);
	result = FALSE;
	return result;
}


/**
         * Restart the 5 seconds timeout before hiding the mouse cursor
         */
static gboolean _pdfpc_window_fullscreen_on_hide_cursor_timeout_gsource_func (gpointer self) {
	gboolean result;
	result = pdfpc_window_fullscreen_on_hide_cursor_timeout (self);
	return result;
}


void pdfpc_window_fullscreen_restart_hide_cursor_timer (pdfpcWindowFullscreen* self) {
	guint _tmp0_;
	guint _tmp2_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->hide_cursor_timeout;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->hide_cursor_timeout;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 5, _pdfpc_window_fullscreen_on_hide_cursor_timeout_gsource_func, g_object_ref (self), g_object_unref);
	self->hide_cursor_timeout = _tmp2_;
}


/**
         * Timeout method called if the mouse pointer has not been moved for 5
         * seconds
         */
gboolean pdfpc_window_fullscreen_on_hide_cursor_timeout (pdfpcWindowFullscreen* self) {
	gboolean result = FALSE;
	GdkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	self->hide_cursor_timeout = (guint) 0;
	_tmp0_ = ((GtkWidget*) self)->window;
	if (_tmp0_ != NULL) {
		GdkWindow* _tmp1_;
		GdkCursor* _tmp2_;
		GdkCursor* _tmp3_;
		_tmp1_ = ((GtkWidget*) self)->window;
		_tmp2_ = gdk_cursor_new (GDK_BLANK_CURSOR);
		_tmp3_ = _tmp2_;
		gdk_window_set_cursor (_tmp1_, _tmp3_);
		_gdk_cursor_unref0 (_tmp3_);
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}


static void pdfpc_window_fullscreen_class_init (pdfpcWindowFullscreenClass * klass) {
	pdfpc_window_fullscreen_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = pdfpc_window_fullscreen_finalize;
}


static void pdfpc_window_fullscreen_instance_init (pdfpcWindowFullscreen * self) {
	self->hide_cursor_timeout = (guint) 0;
	self->faded_to_black = FALSE;
	self->frozen = FALSE;
}


static void pdfpc_window_fullscreen_finalize (GObject* obj) {
	pdfpcWindowFullscreen * self;
	self = PDFPC_WINDOW_FULLSCREEN (obj);
	G_OBJECT_CLASS (pdfpc_window_fullscreen_parent_class)->finalize (obj);
}


/**
     * Window extension implementing all the needed functionality, to be
     * displayed fullscreen.
     *
     * Methods to specify the monitor to be displayed on in a multi-head setup
     * are provided as well.
     */
GType pdfpc_window_fullscreen_get_type (void) {
	static volatile gsize pdfpc_window_fullscreen_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_window_fullscreen_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcWindowFullscreenClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_window_fullscreen_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcWindowFullscreen), 0, (GInstanceInitFunc) pdfpc_window_fullscreen_instance_init, NULL };
		GType pdfpc_window_fullscreen_type_id;
		pdfpc_window_fullscreen_type_id = g_type_register_static (GTK_TYPE_WINDOW, "pdfpcWindowFullscreen", &g_define_type_info, 0);
		g_once_init_leave (&pdfpc_window_fullscreen_type_id__volatile, pdfpc_window_fullscreen_type_id);
	}
	return pdfpc_window_fullscreen_type_id__volatile;
}



