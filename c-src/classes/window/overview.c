/* overview.c generated by valac 0.16.0, the Vala compiler
 * generated from overview.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk/gdk.h>
#include <string.h>
#include <cairo.h>


#define PDFPC_WINDOW_TYPE_OVERVIEW (pdfpc_window_overview_get_type ())
#define PDFPC_WINDOW_OVERVIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_OVERVIEW, pdfpcWindowOverview))
#define PDFPC_WINDOW_OVERVIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_OVERVIEW, pdfpcWindowOverviewClass))
#define PDFPC_WINDOW_IS_OVERVIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_OVERVIEW))
#define PDFPC_WINDOW_IS_OVERVIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_OVERVIEW))
#define PDFPC_WINDOW_OVERVIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_OVERVIEW, pdfpcWindowOverviewClass))

typedef struct _pdfpcWindowOverview pdfpcWindowOverview;
typedef struct _pdfpcWindowOverviewClass pdfpcWindowOverviewClass;
typedef struct _pdfpcWindowOverviewPrivate pdfpcWindowOverviewPrivate;

#define PDFPC_METADATA_TYPE_BASE (pdfpc_metadata_base_get_type ())
#define PDFPC_METADATA_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBase))
#define PDFPC_METADATA_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))
#define PDFPC_METADATA_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_BASE))
#define PDFPC_METADATA_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_BASE, pdfpcMetadataBaseClass))

typedef struct _pdfpcMetadataBase pdfpcMetadataBase;
typedef struct _pdfpcMetadataBaseClass pdfpcMetadataBaseClass;

#define PDFPC_METADATA_TYPE_PDF (pdfpc_metadata_pdf_get_type ())
#define PDFPC_METADATA_PDF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdf))
#define PDFPC_METADATA_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))
#define PDFPC_METADATA_IS_PDF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_IS_PDF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_METADATA_TYPE_PDF))
#define PDFPC_METADATA_PDF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_METADATA_TYPE_PDF, pdfpcMetadataPdfClass))

typedef struct _pdfpcMetadataPdf pdfpcMetadataPdf;
typedef struct _pdfpcMetadataPdfClass pdfpcMetadataPdfClass;

#define PDFPC_RENDERER_CACHE_TYPE_BASE (pdfpc_renderer_cache_base_get_type ())
#define PDFPC_RENDERER_CACHE_BASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBase))
#define PDFPC_RENDERER_CACHE_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))
#define PDFPC_RENDERER_CACHE_IS_BASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_IS_BASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_RENDERER_CACHE_TYPE_BASE))
#define PDFPC_RENDERER_CACHE_BASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_RENDERER_CACHE_TYPE_BASE, pdfpcRendererCacheBaseClass))

typedef struct _pdfpcRendererCacheBase pdfpcRendererCacheBase;
typedef struct _pdfpcRendererCacheBaseClass pdfpcRendererCacheBaseClass;

#define PDFPC_TYPE_PRESENTATION_CONTROLLER (pdfpc_presentation_controller_get_type ())
#define PDFPC_PRESENTATION_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationController))
#define PDFPC_PRESENTATION_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationControllerClass))
#define PDFPC_IS_PRESENTATION_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER))
#define PDFPC_IS_PRESENTATION_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_TYPE_PRESENTATION_CONTROLLER))
#define PDFPC_PRESENTATION_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_TYPE_PRESENTATION_CONTROLLER, pdfpcPresentationControllerClass))

typedef struct _pdfpcPresentationController pdfpcPresentationController;
typedef struct _pdfpcPresentationControllerClass pdfpcPresentationControllerClass;

#define PDFPC_WINDOW_TYPE_FULLSCREEN (pdfpc_window_fullscreen_get_type ())
#define PDFPC_WINDOW_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreen))
#define PDFPC_WINDOW_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))
#define PDFPC_WINDOW_IS_FULLSCREEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_IS_FULLSCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_FULLSCREEN))
#define PDFPC_WINDOW_FULLSCREEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_FULLSCREEN, pdfpcWindowFullscreenClass))

typedef struct _pdfpcWindowFullscreen pdfpcWindowFullscreen;
typedef struct _pdfpcWindowFullscreenClass pdfpcWindowFullscreenClass;

#define PDFPC_WINDOW_TYPE_PRESENTER (pdfpc_window_presenter_get_type ())
#define PDFPC_WINDOW_PRESENTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_PRESENTER, pdfpcWindowPresenter))
#define PDFPC_WINDOW_PRESENTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_PRESENTER, pdfpcWindowPresenterClass))
#define PDFPC_WINDOW_IS_PRESENTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_PRESENTER))
#define PDFPC_WINDOW_IS_PRESENTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_PRESENTER))
#define PDFPC_WINDOW_PRESENTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_PRESENTER, pdfpcWindowPresenterClass))

typedef struct _pdfpcWindowPresenter pdfpcWindowPresenter;
typedef struct _pdfpcWindowPresenterClass pdfpcWindowPresenterClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define __g_list_free__gtk_tree_path_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__gtk_tree_path_free0_ (var), NULL)))

#define PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT (pdfpc_window_cell_renderer_highlight_get_type ())
#define PDFPC_WINDOW_CELL_RENDERER_HIGHLIGHT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT, pdfpcWindowCellRendererHighlight))
#define PDFPC_WINDOW_CELL_RENDERER_HIGHLIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT, pdfpcWindowCellRendererHighlightClass))
#define PDFPC_WINDOW_IS_CELL_RENDERER_HIGHLIGHT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT))
#define PDFPC_WINDOW_IS_CELL_RENDERER_HIGHLIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT))
#define PDFPC_WINDOW_CELL_RENDERER_HIGHLIGHT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT, pdfpcWindowCellRendererHighlightClass))

typedef struct _pdfpcWindowCellRendererHighlight pdfpcWindowCellRendererHighlight;
typedef struct _pdfpcWindowCellRendererHighlightClass pdfpcWindowCellRendererHighlightClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _pdfpcWindowCellRendererHighlightPrivate pdfpcWindowCellRendererHighlightPrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

struct _pdfpcWindowOverview {
	GtkScrolledWindow parent_instance;
	pdfpcWindowOverviewPrivate * priv;
	GtkListStore* slides;
	GtkIconView* slides_view;
	pdfpcMetadataPdf* metadata;
	gint n_slides;
	gint last_structure_n_slides;
	gint target_width;
	gint target_height;
	gint next_undone_preview;
	guint idle_id;
	pdfpcRendererCacheBase* cache;
	pdfpcPresentationController* presentation_controller;
	pdfpcWindowPresenter* presenter;
	gdouble aspect_ratio;
	gint max_width;
	gint max_height;
};

struct _pdfpcWindowOverviewClass {
	GtkScrolledWindowClass parent_class;
};

struct _pdfpcWindowOverviewPrivate {
	gint _current_slide;
};

struct _pdfpcWindowCellRendererHighlight {
	GtkCellRendererPixbuf parent_instance;
	pdfpcWindowCellRendererHighlightPrivate * priv;
};

struct _pdfpcWindowCellRendererHighlightClass {
	GtkCellRendererPixbufClass parent_class;
};


static gpointer pdfpc_window_overview_parent_class = NULL;
extern gint pdfpc_options_min_overview_width;
static gpointer pdfpc_window_cell_renderer_highlight_parent_class = NULL;

GType pdfpc_window_overview_get_type (void) G_GNUC_CONST;
GType pdfpc_metadata_base_get_type (void) G_GNUC_CONST;
GType pdfpc_metadata_pdf_get_type (void) G_GNUC_CONST;
GType pdfpc_renderer_cache_base_get_type (void) G_GNUC_CONST;
GType pdfpc_presentation_controller_get_type (void) G_GNUC_CONST;
GType pdfpc_window_fullscreen_get_type (void) G_GNUC_CONST;
GType pdfpc_window_presenter_get_type (void) G_GNUC_CONST;
#define PDFPC_WINDOW_OVERVIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PDFPC_WINDOW_TYPE_OVERVIEW, pdfpcWindowOverviewPrivate))
enum  {
	PDFPC_WINDOW_OVERVIEW_DUMMY_PROPERTY,
	PDFPC_WINDOW_OVERVIEW_CURRENT_SLIDE
};
void pdfpc_window_overview_on_selection_changed (pdfpcWindowOverview* self, GtkWidget* source);
void pdfpc_window_presenter_custom_slide_count (pdfpcWindowPresenter* self, gint current);
static void _gtk_tree_path_free0_ (gpointer var);
static void _g_list_free__gtk_tree_path_free0_ (GList* self);
void pdfpc_window_overview_set_current_slide (pdfpcWindowOverview* self, gint value);
pdfpcWindowOverview* pdfpc_window_overview_new (pdfpcMetadataPdf* metadata, pdfpcPresentationController* presentation_controller, pdfpcWindowPresenter* presenter);
pdfpcWindowOverview* pdfpc_window_overview_construct (GType object_type, pdfpcMetadataPdf* metadata, pdfpcPresentationController* presentation_controller, pdfpcWindowPresenter* presenter);
pdfpcWindowCellRendererHighlight* pdfpc_window_cell_renderer_highlight_new (void);
pdfpcWindowCellRendererHighlight* pdfpc_window_cell_renderer_highlight_construct (GType object_type);
GType pdfpc_window_cell_renderer_highlight_get_type (void) G_GNUC_CONST;
gboolean pdfpc_window_fullscreen_on_mouse_move (pdfpcWindowFullscreen* self, GtkWidget* source, GdkEventMotion* event);
static gboolean _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
gboolean pdfpc_window_overview_on_mouse_move (pdfpcWindowOverview* self, GtkWidget* source, GdkEventMotion* event);
static gboolean _pdfpc_window_overview_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
gboolean pdfpc_window_overview_on_mouse_release (pdfpcWindowOverview* self, GdkEventButton* event);
static gboolean _pdfpc_window_overview_on_mouse_release_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
gboolean pdfpc_window_overview_on_key_press (pdfpcWindowOverview* self, GtkWidget* source, GdkEventKey* key);
static gboolean _pdfpc_window_overview_on_key_press_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static void _pdfpc_window_overview_on_selection_changed_gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self);
void pdfpc_window_overview_on_parent_set (pdfpcWindowOverview* self, GtkWidget* old_parent);
static void _pdfpc_window_overview_on_parent_set_gtk_widget_parent_set (GtkWidget* _sender, GtkWidget* previous_parent, gpointer self);
gdouble pdfpc_metadata_pdf_get_page_width (pdfpcMetadataPdf* self);
gdouble pdfpc_metadata_pdf_get_page_height (pdfpcMetadataPdf* self);
void pdfpc_window_overview_set_available_space (pdfpcWindowOverview* self, gint width, gint height);
void pdfpc_window_overview_fill_structure (pdfpcWindowOverview* self);
void pdfpc_window_overview_on_show (pdfpcWindowOverview* self);
static void _pdfpc_window_overview_on_show_gtk_widget_show (GtkWidget* _sender, gpointer self);
void pdfpc_window_overview_on_hide (pdfpcWindowOverview* self);
static void _pdfpc_window_overview_on_hide_gtk_widget_hide (GtkWidget* _sender, gpointer self);
void pdfpc_window_overview_fill_previews (pdfpcWindowOverview* self);
gboolean _pdfpc_window_overview_fill_previews (pdfpcWindowOverview* self);
static gboolean __pdfpc_window_overview_fill_previews_gsource_func (gpointer self);
GdkPixmap* pdfpc_renderer_cache_base_retrieve (pdfpcRendererCacheBase* self, guint index);
gint pdfpc_metadata_pdf_user_slide_to_real_slide (pdfpcMetadataPdf* self, gint number);
void pdfpc_window_overview_set_cache (pdfpcWindowOverview* self, pdfpcRendererCacheBase* cache);
void pdfpc_window_overview_set_n_slides (pdfpcWindowOverview* self, gint n);
gint pdfpc_window_overview_get_current_slide (pdfpcWindowOverview* self);
void pdfpc_window_overview_remove_current (pdfpcWindowOverview* self, gint newn);
void pdfpc_presentation_controller_goto_user_page (pdfpcPresentationController* self, gint page_number);
static void pdfpc_window_overview_finalize (GObject* obj);
static void _vala_pdfpc_window_overview_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_pdfpc_window_overview_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
enum  {
	PDFPC_WINDOW_CELL_RENDERER_HIGHLIGHT_DUMMY_PROPERTY
};
static void pdfpc_window_cell_renderer_highlight_real_render (GtkCellRenderer* base, GdkWindow* window, GtkWidget* widget, GdkRectangle* background_area, GdkRectangle* cell_area, GdkRectangle* expose_area, GtkCellRendererState flags);


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


static void _gtk_tree_path_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL));
}


static void _g_list_free__gtk_tree_path_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _gtk_tree_path_free0_, NULL);
	g_list_free (self);
}


void pdfpc_window_overview_on_selection_changed (pdfpcWindowOverview* self, GtkWidget* source) {
	GtkIconView* _tmp0_;
	GList* _tmp1_ = NULL;
	GList* ltp;
	GList* _tmp2_;
	gint _tmp13_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->slides_view;
	_tmp1_ = gtk_icon_view_get_selected_items (_tmp0_);
	ltp = _tmp1_;
	_tmp2_ = ltp;
	if (_tmp2_ != NULL) {
		GList* _tmp3_;
		gconstpointer _tmp4_;
		GtkTreePath* _tmp5_;
		GtkTreePath* tp;
		GtkTreePath* _tmp6_;
		gint* _tmp7_ = NULL;
		_tmp3_ = ltp;
		_tmp4_ = _tmp3_->data;
		_tmp5_ = _gtk_tree_path_copy0 ((GtkTreePath*) _tmp4_);
		tp = _tmp5_;
		_tmp6_ = tp;
		_tmp7_ = gtk_tree_path_get_indices (_tmp6_);
		if (_tmp7_ != NULL) {
			GtkTreePath* _tmp8_;
			gint* _tmp9_ = NULL;
			gint _tmp10_;
			pdfpcWindowPresenter* _tmp11_;
			gint _tmp12_;
			_tmp8_ = tp;
			_tmp9_ = gtk_tree_path_get_indices (_tmp8_);
			_tmp10_ = _tmp9_[0];
			self->priv->_current_slide = _tmp10_;
			_tmp11_ = self->presenter;
			_tmp12_ = self->priv->_current_slide;
			pdfpc_window_presenter_custom_slide_count (_tmp11_, _tmp12_ + 1);
			_gtk_tree_path_free0 (tp);
			__g_list_free__gtk_tree_path_free0_0 (ltp);
			return;
		}
		_gtk_tree_path_free0 (tp);
	}
	_tmp13_ = self->priv->_current_slide;
	pdfpc_window_overview_set_current_slide (self, _tmp13_);
	__g_list_free__gtk_tree_path_free0_0 (ltp);
}


/**
         * Constructor
         */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_fullscreen_on_mouse_move (self, _sender, event);
	return result;
}


static gboolean _pdfpc_window_overview_on_mouse_move_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_overview_on_mouse_move (self, _sender, event);
	return result;
}


static gboolean _pdfpc_window_overview_on_mouse_release_gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_overview_on_mouse_release (self, event);
	return result;
}


static gboolean _pdfpc_window_overview_on_key_press_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = pdfpc_window_overview_on_key_press (self, _sender, event);
	return result;
}


static void _pdfpc_window_overview_on_selection_changed_gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self) {
	pdfpc_window_overview_on_selection_changed (self, _sender);
}


static void _pdfpc_window_overview_on_parent_set_gtk_widget_parent_set (GtkWidget* _sender, GtkWidget* previous_parent, gpointer self) {
	pdfpc_window_overview_on_parent_set (self, previous_parent);
}


pdfpcWindowOverview* pdfpc_window_overview_construct (GType object_type, pdfpcMetadataPdf* metadata, pdfpcPresentationController* presentation_controller, pdfpcWindowPresenter* presenter) {
	pdfpcWindowOverview * self = NULL;
	GtkListStore* _tmp0_;
	GtkListStore* _tmp1_;
	GtkIconView* _tmp2_;
	GtkIconView* _tmp3_;
	GtkIconView* _tmp4_;
	pdfpcWindowCellRendererHighlight* _tmp5_;
	pdfpcWindowCellRendererHighlight* _tmp6_;
	pdfpcWindowCellRendererHighlight* renderer;
	GtkIconView* _tmp7_;
	GtkIconView* _tmp8_;
	GtkIconView* _tmp9_;
	GtkIconView* _tmp10_;
	GdkColor black = {0};
	GdkColor white = {0};
	GdkColor _tmp11_ = {0};
	GdkColor _tmp12_ = {0};
	GtkIconView* _tmp13_;
	GdkColor _tmp14_;
	GtkWidget* _tmp15_ = NULL;
	GtkScrollbar* _tmp16_;
	GtkScrollbar* vscrollbar;
	GdkColor _tmp17_;
	GdkColor _tmp18_;
	GdkColor _tmp19_;
	pdfpcMetadataPdf* _tmp20_;
	pdfpcMetadataPdf* _tmp21_;
	pdfpcPresentationController* _tmp22_;
	pdfpcPresentationController* _tmp23_;
	pdfpcWindowPresenter* _tmp24_;
	pdfpcWindowPresenter* _tmp25_;
	GtkIconView* _tmp26_;
	pdfpcWindowPresenter* _tmp27_;
	GtkIconView* _tmp28_;
	GtkIconView* _tmp29_;
	GtkIconView* _tmp30_;
	GtkIconView* _tmp31_;
	pdfpcMetadataPdf* _tmp32_;
	gdouble _tmp33_ = 0.0;
	pdfpcMetadataPdf* _tmp34_;
	gdouble _tmp35_ = 0.0;
	g_return_val_if_fail (metadata != NULL, NULL);
	g_return_val_if_fail (presentation_controller != NULL, NULL);
	g_return_val_if_fail (presenter != NULL, NULL);
	self = (pdfpcWindowOverview*) g_object_new (object_type, NULL);
	_tmp0_ = gtk_list_store_new (1, GDK_TYPE_PIXBUF);
	_g_object_unref0 (self->slides);
	self->slides = _tmp0_;
	_tmp1_ = self->slides;
	_tmp2_ = (GtkIconView*) gtk_icon_view_new_with_model ((GtkTreeModel*) _tmp1_);
	_tmp3_ = g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->slides_view);
	self->slides_view = _tmp3_;
	_tmp4_ = self->slides_view;
	gtk_icon_view_set_selection_mode (_tmp4_, GTK_SELECTION_SINGLE);
	_tmp5_ = pdfpc_window_cell_renderer_highlight_new ();
	_tmp6_ = g_object_ref_sink (_tmp5_);
	renderer = _tmp6_;
	_tmp7_ = self->slides_view;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp7_, (GtkCellRenderer*) renderer, TRUE);
	_tmp8_ = self->slides_view;
	gtk_cell_layout_add_attribute ((GtkCellLayout*) _tmp8_, (GtkCellRenderer*) renderer, "pixbuf", 0);
	_tmp9_ = self->slides_view;
	gtk_icon_view_set_item_padding (_tmp9_, 0);
	_tmp10_ = self->slides_view;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp10_);
	gtk_widget_show_all ((GtkWidget*) self);
	gdk_color_parse ("black", &_tmp11_);
	black = _tmp11_;
	gdk_color_parse ("white", &_tmp12_);
	white = _tmp12_;
	_tmp13_ = self->slides_view;
	_tmp14_ = black;
	gtk_widget_modify_base ((GtkWidget*) _tmp13_, GTK_STATE_NORMAL, &_tmp14_);
	_tmp15_ = gtk_scrolled_window_get_vscrollbar ((GtkScrolledWindow*) self);
	_tmp16_ = _g_object_ref0 (GTK_SCROLLBAR (_tmp15_));
	vscrollbar = _tmp16_;
	_tmp17_ = white;
	gtk_widget_modify_bg ((GtkWidget*) vscrollbar, GTK_STATE_NORMAL, &_tmp17_);
	_tmp18_ = black;
	gtk_widget_modify_bg ((GtkWidget*) vscrollbar, GTK_STATE_ACTIVE, &_tmp18_);
	_tmp19_ = white;
	gtk_widget_modify_bg ((GtkWidget*) vscrollbar, GTK_STATE_PRELIGHT, &_tmp19_);
	_tmp20_ = metadata;
	_tmp21_ = _g_object_ref0 (_tmp20_);
	_g_object_unref0 (self->metadata);
	self->metadata = _tmp21_;
	_tmp22_ = presentation_controller;
	_tmp23_ = _g_object_ref0 (_tmp22_);
	_g_object_unref0 (self->presentation_controller);
	self->presentation_controller = _tmp23_;
	_tmp24_ = presenter;
	_tmp25_ = _g_object_ref0 (_tmp24_);
	_g_object_unref0 (self->presenter);
	self->presenter = _tmp25_;
	_tmp26_ = self->slides_view;
	_tmp27_ = self->presenter;
	g_signal_connect_object ((GtkWidget*) _tmp26_, "motion-notify-event", (GCallback) _pdfpc_window_fullscreen_on_mouse_move_gtk_widget_motion_notify_event, (pdfpcWindowFullscreen*) _tmp27_, 0);
	_tmp28_ = self->slides_view;
	g_signal_connect_object ((GtkWidget*) _tmp28_, "motion-notify-event", (GCallback) _pdfpc_window_overview_on_mouse_move_gtk_widget_motion_notify_event, self, 0);
	_tmp29_ = self->slides_view;
	g_signal_connect_object ((GtkWidget*) _tmp29_, "button-release-event", (GCallback) _pdfpc_window_overview_on_mouse_release_gtk_widget_button_release_event, self, 0);
	_tmp30_ = self->slides_view;
	g_signal_connect_object ((GtkWidget*) _tmp30_, "key-press-event", (GCallback) _pdfpc_window_overview_on_key_press_gtk_widget_key_press_event, self, 0);
	_tmp31_ = self->slides_view;
	g_signal_connect_object (_tmp31_, "selection-changed", (GCallback) _pdfpc_window_overview_on_selection_changed_gtk_icon_view_selection_changed, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "parent-set", (GCallback) _pdfpc_window_overview_on_parent_set_gtk_widget_parent_set, self, 0);
	_tmp32_ = self->metadata;
	_tmp33_ = pdfpc_metadata_pdf_get_page_width (_tmp32_);
	_tmp34_ = self->metadata;
	_tmp35_ = pdfpc_metadata_pdf_get_page_height (_tmp34_);
	self->aspect_ratio = _tmp33_ / _tmp35_;
	_g_object_unref0 (vscrollbar);
	_g_object_unref0 (renderer);
	return self;
}


pdfpcWindowOverview* pdfpc_window_overview_new (pdfpcMetadataPdf* metadata, pdfpcPresentationController* presentation_controller, pdfpcWindowPresenter* presenter) {
	return pdfpc_window_overview_construct (PDFPC_WINDOW_TYPE_OVERVIEW, metadata, presentation_controller, presenter);
}


void pdfpc_window_overview_set_available_space (pdfpcWindowOverview* self, gint width, gint height) {
	gint _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = width;
	self->max_width = _tmp0_;
	_tmp1_ = height;
	self->max_height = _tmp1_;
	pdfpc_window_overview_fill_structure (self);
}


static void _pdfpc_window_overview_on_show_gtk_widget_show (GtkWidget* _sender, gpointer self) {
	pdfpc_window_overview_on_show (self);
}


static void _pdfpc_window_overview_on_hide_gtk_widget_hide (GtkWidget* _sender, gpointer self) {
	pdfpc_window_overview_on_hide (self);
}


void pdfpc_window_overview_on_parent_set (pdfpcWindowOverview* self, GtkWidget* old_parent) {
	GtkContainer* _tmp0_;
	GtkContainer* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_parent ((GtkWidget*) self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		GtkContainer* _tmp2_;
		GtkContainer* _tmp3_;
		GtkContainer* _tmp4_;
		GtkContainer* _tmp5_;
		_tmp2_ = gtk_widget_get_parent ((GtkWidget*) self);
		_tmp3_ = _tmp2_;
		g_signal_connect_object ((GtkWidget*) _tmp3_, "show", (GCallback) _pdfpc_window_overview_on_show_gtk_widget_show, self, 0);
		_tmp4_ = gtk_widget_get_parent ((GtkWidget*) self);
		_tmp5_ = _tmp4_;
		g_signal_connect_object ((GtkWidget*) _tmp5_, "hide", (GCallback) _pdfpc_window_overview_on_hide_gtk_widget_hide, self, 0);
	}
}


/**
         * Get keyboard focus.
         */
void pdfpc_window_overview_on_show (pdfpcWindowOverview* self) {
	GtkIconView* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->slides_view;
	gtk_widget_grab_focus ((GtkWidget*) _tmp0_);
}


void pdfpc_window_overview_on_hide (pdfpcWindowOverview* self) {
	gint _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->n_slides;
	_tmp1_ = self->last_structure_n_slides;
	if (_tmp0_ != _tmp1_) {
		pdfpc_window_overview_fill_structure (self);
	}
}


/**
         * Figure out the sizes for the icons, and create entries in slides
         * for all the slides.
         */
void pdfpc_window_overview_fill_structure (pdfpcWindowOverview* self) {
	gint _tmp0_;
	GtkIconView* _tmp1_;
	GtkIconView* _tmp2_;
	gint _tmp3_ = 0;
	gint margin;
	GtkIconView* _tmp4_;
	gint _tmp5_ = 0;
	gint padding;
	GtkIconView* _tmp6_;
	gint _tmp7_ = 0;
	gint row_spacing;
	GtkIconView* _tmp8_;
	gint _tmp9_ = 0;
	gint col_spacing;
	gint _tmp10_;
	gint _tmp11_;
	gint eff_max_width;
	gint _tmp12_;
	gint _tmp13_;
	gint eff_max_height;
	gint _tmp14_;
	gint _tmp15_;
	gint _tmp16_;
	gint _tmp17_;
	gint cols;
	gint widthx = 0;
	gint widthy = 0;
	gint min_width = 0;
	gint rows = 0;
	gint tc;
	gint _tmp45_;
	gint _tmp46_;
	gint _tmp55_;
	gdouble _tmp56_;
	gdouble _tmp57_ = 0.0;
	gint _tmp58_;
	GtkIconView* _tmp59_;
	gint _tmp60_;
	gint _tmp61_;
	gdouble _tmp62_ = 0.0;
	gint _tmp63_;
	gint _tmp64_;
	gint _tmp65_;
	gint _tmp66_;
	gint _tmp67_;
	gint full_height;
	gint _tmp68_;
	gint _tmp69_;
	gint _tmp71_;
	gint _tmp72_;
	GtkListStore* _tmp73_;
	gint _tmp74_;
	gint _tmp75_;
	GdkPixbuf* _tmp76_;
	GdkPixbuf* pixbuf;
	GdkPixbuf* _tmp77_;
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->max_width;
	if (_tmp0_ == (-1)) {
		return;
	}
	_tmp1_ = self->slides_view;
	gtk_icon_view_set_margin (_tmp1_, 0);
	_tmp2_ = self->slides_view;
	_tmp3_ = gtk_icon_view_get_margin (_tmp2_);
	margin = _tmp3_;
	_tmp4_ = self->slides_view;
	_tmp5_ = gtk_icon_view_get_item_padding (_tmp4_);
	padding = _tmp5_ + 1;
	_tmp6_ = self->slides_view;
	_tmp7_ = gtk_icon_view_get_row_spacing (_tmp6_);
	row_spacing = _tmp7_;
	_tmp8_ = self->slides_view;
	_tmp9_ = gtk_icon_view_get_column_spacing (_tmp8_);
	col_spacing = _tmp9_;
	_tmp10_ = self->max_width;
	_tmp11_ = margin;
	eff_max_width = _tmp10_ - (2 * _tmp11_);
	_tmp12_ = self->max_height;
	_tmp13_ = margin;
	eff_max_height = _tmp12_ - (2 * _tmp13_);
	_tmp14_ = eff_max_width;
	_tmp15_ = pdfpc_options_min_overview_width;
	_tmp16_ = padding;
	_tmp17_ = col_spacing;
	cols = _tmp14_ / ((_tmp15_ + (2 * _tmp16_)) + _tmp17_);
	tc = 0;
	self->target_width = 0;
	while (TRUE) {
		gint _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gint _tmp22_;
		gint _tmp23_;
		gint _tmp24_;
		gdouble _tmp25_ = 0.0;
		gint _tmp26_;
		gint _tmp27_;
		gint _tmp28_;
		gint _tmp29_;
		gdouble _tmp30_;
		gdouble _tmp31_ = 0.0;
		gint _tmp32_;
		gint _tmp33_;
		gint _tmp34_ = 0;
		gint _tmp35_;
		gint _tmp36_;
		gint _tmp39_;
		gint _tmp40_;
		gint _tmp41_;
		gint _tmp44_;
		_tmp18_ = cols;
		if (!(_tmp18_ > 0)) {
			break;
		}
		_tmp19_ = eff_max_width;
		_tmp20_ = cols;
		_tmp21_ = padding;
		_tmp22_ = col_spacing;
		widthx = ((_tmp19_ / _tmp20_) - (2 * _tmp21_)) - (2 * _tmp22_);
		_tmp23_ = self->n_slides;
		_tmp24_ = cols;
		_tmp25_ = ceil ((gdouble) (((gfloat) _tmp23_) / _tmp24_));
		rows = (gint) _tmp25_;
		_tmp26_ = eff_max_height;
		_tmp27_ = rows;
		_tmp28_ = padding;
		_tmp29_ = row_spacing;
		_tmp30_ = self->aspect_ratio;
		_tmp31_ = floor ((((_tmp26_ / _tmp27_) - (2 * _tmp28_)) - (2 * _tmp29_)) * _tmp30_);
		widthy = (gint) _tmp31_;
		_tmp32_ = widthy;
		_tmp33_ = pdfpc_options_min_overview_width;
		if (_tmp32_ < _tmp33_) {
			break;
		}
		_tmp35_ = widthx;
		_tmp36_ = widthy;
		if (_tmp35_ < _tmp36_) {
			gint _tmp37_;
			_tmp37_ = widthx;
			_tmp34_ = _tmp37_;
		} else {
			gint _tmp38_;
			_tmp38_ = widthy;
			_tmp34_ = _tmp38_;
		}
		_tmp39_ = _tmp34_;
		min_width = _tmp39_;
		_tmp40_ = min_width;
		_tmp41_ = self->target_width;
		if (_tmp40_ >= _tmp41_) {
			gint _tmp42_;
			gint _tmp43_;
			_tmp42_ = min_width;
			self->target_width = _tmp42_;
			_tmp43_ = cols;
			tc = _tmp43_;
		}
		_tmp44_ = cols;
		cols = _tmp44_ - 1;
	}
	_tmp45_ = self->target_width;
	_tmp46_ = pdfpc_options_min_overview_width;
	if (_tmp45_ < _tmp46_) {
		gint _tmp47_;
		GtkIconView* _tmp48_;
		gint _tmp49_;
		gint _tmp50_;
		gint _tmp51_;
		gint _tmp52_;
		_tmp47_ = pdfpc_options_min_overview_width;
		self->target_width = _tmp47_;
		_tmp48_ = self->slides_view;
		_tmp49_ = eff_max_width;
		_tmp50_ = pdfpc_options_min_overview_width;
		_tmp51_ = padding;
		_tmp52_ = col_spacing;
		gtk_icon_view_set_columns (_tmp48_, (_tmp49_ - 20) / ((_tmp50_ + (2 * _tmp51_)) + _tmp52_));
	} else {
		GtkIconView* _tmp53_;
		gint _tmp54_;
		_tmp53_ = self->slides_view;
		_tmp54_ = tc;
		gtk_icon_view_set_columns (_tmp53_, _tmp54_);
	}
	gtk_scrolled_window_set_policy ((GtkScrolledWindow*) self, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	_tmp55_ = self->target_width;
	_tmp56_ = self->aspect_ratio;
	_tmp57_ = round (_tmp55_ / _tmp56_);
	self->target_height = (gint) _tmp57_;
	_tmp58_ = self->n_slides;
	_tmp59_ = self->slides_view;
	_tmp60_ = gtk_icon_view_get_columns (_tmp59_);
	_tmp61_ = _tmp60_;
	_tmp62_ = ceil ((gdouble) (((gfloat) _tmp58_) / _tmp61_));
	rows = (gint) _tmp62_;
	_tmp63_ = rows;
	_tmp64_ = self->target_height;
	_tmp65_ = padding;
	_tmp66_ = row_spacing;
	_tmp67_ = margin;
	full_height = (_tmp63_ * ((_tmp64_ + (2 * _tmp65_)) + (2 * _tmp66_))) + (2 * _tmp67_);
	_tmp68_ = full_height;
	_tmp69_ = self->max_height;
	if (_tmp68_ > _tmp69_) {
		gint _tmp70_;
		_tmp70_ = self->max_height;
		full_height = _tmp70_;
	}
	_tmp71_ = full_height;
	gtk_widget_set_size_request ((GtkWidget*) self, -1, _tmp71_);
	_tmp72_ = self->n_slides;
	self->last_structure_n_slides = _tmp72_;
	_tmp73_ = self->slides;
	gtk_list_store_clear (_tmp73_);
	_tmp74_ = self->target_width;
	_tmp75_ = self->target_height;
	_tmp76_ = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, _tmp74_, _tmp75_);
	pixbuf = _tmp76_;
	_tmp77_ = pixbuf;
	gdk_pixbuf_fill (_tmp77_, (guint32) 0x7f7f7fff);
	memset (&iter, 0, sizeof (GtkTreeIter));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp78_;
			_tmp78_ = TRUE;
			while (TRUE) {
				gboolean _tmp79_;
				gint _tmp81_;
				gint _tmp82_;
				GtkListStore* _tmp83_;
				GtkTreeIter _tmp84_ = {0};
				GtkListStore* _tmp85_;
				GtkTreeIter _tmp86_;
				GdkPixbuf* _tmp87_;
				GValue _tmp88_ = {0};
				_tmp79_ = _tmp78_;
				if (!_tmp79_) {
					gint _tmp80_;
					_tmp80_ = i;
					i = _tmp80_ + 1;
				}
				_tmp78_ = FALSE;
				_tmp81_ = i;
				_tmp82_ = self->n_slides;
				if (!(_tmp81_ < _tmp82_)) {
					break;
				}
				_tmp83_ = self->slides;
				gtk_list_store_append (_tmp83_, &_tmp84_);
				iter = _tmp84_;
				_tmp85_ = self->slides;
				_tmp86_ = iter;
				_tmp87_ = pixbuf;
				g_value_init (&_tmp88_, GDK_TYPE_PIXBUF);
				g_value_set_object (&_tmp88_, _tmp87_);
				gtk_list_store_set_value (_tmp85_, &_tmp86_, 0, &_tmp88_);
				G_IS_VALUE (&_tmp88_) ? (g_value_unset (&_tmp88_), NULL) : NULL;
			}
		}
	}
	pdfpc_window_overview_fill_previews (self);
	_g_object_unref0 (pixbuf);
}


/**
         * Fill the previews (only if we have a cache and we are displayed).
         * The size of the icons should be known already
         *
         * This is done in a progressive way (one slide at a time) instead of
         * all the slides in one go to provide some progress feedback to the
         * user.
         */
static gboolean __pdfpc_window_overview_fill_previews_gsource_func (gpointer self) {
	gboolean result;
	result = _pdfpc_window_overview_fill_previews (self);
	return result;
}


void pdfpc_window_overview_fill_previews (pdfpcWindowOverview* self) {
	guint _tmp0_;
	guint _tmp2_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->idle_id;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->idle_id;
		g_source_remove (_tmp1_);
	}
	self->next_undone_preview = 0;
	_tmp2_ = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __pdfpc_window_overview_fill_previews_gsource_func, g_object_ref (self), g_object_unref);
	self->idle_id = _tmp2_;
}


gboolean _pdfpc_window_overview_fill_previews (pdfpcWindowOverview* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	pdfpcRendererCacheBase* _tmp1_;
	gboolean _tmp4_;
	gint pixmap_width = 0;
	gint pixmap_height = 0;
	pdfpcRendererCacheBase* _tmp5_;
	GdkPixmap* _tmp6_ = NULL;
	GdkPixmap* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gint _tmp10_;
	gint _tmp11_;
	GdkPixbuf* _tmp12_;
	GdkPixbuf* pixbuf;
	GdkPixbuf* _tmp13_;
	pdfpcRendererCacheBase* _tmp14_;
	pdfpcMetadataPdf* _tmp15_;
	gint _tmp16_;
	gint _tmp17_ = 0;
	GdkPixmap* _tmp18_ = NULL;
	GdkPixmap* _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	GdkPixbuf* _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	GdkPixbuf* _tmp25_ = NULL;
	GdkPixbuf* pixbuf_scaled;
	GtkTreeIter iter = {0};
	GtkListStore* _tmp26_;
	gint _tmp27_;
	gchar* _tmp28_ = NULL;
	gchar* _tmp29_;
	GtkTreeIter _tmp30_ = {0};
	GtkListStore* _tmp31_;
	GtkTreeIter _tmp32_;
	GdkPixbuf* _tmp33_;
	GValue _tmp34_ = {0};
	gint _tmp35_;
	gint _tmp36_;
	gint _tmp37_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->cache;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		gint _tmp3_;
		_tmp2_ = self->next_undone_preview;
		_tmp3_ = self->n_slides;
		_tmp0_ = _tmp2_ >= _tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		result = FALSE;
		return result;
	}
	_tmp5_ = self->cache;
	_tmp6_ = pdfpc_renderer_cache_base_retrieve (_tmp5_, (guint) 0);
	_tmp7_ = _tmp6_;
	gdk_drawable_get_size ((GdkDrawable*) _tmp7_, &_tmp8_, &_tmp9_);
	pixmap_width = _tmp8_;
	pixmap_height = _tmp9_;
	_g_object_unref0 (_tmp7_);
	_tmp10_ = pixmap_width;
	_tmp11_ = pixmap_height;
	_tmp12_ = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, _tmp10_, _tmp11_);
	pixbuf = _tmp12_;
	_tmp13_ = pixbuf;
	_tmp14_ = self->cache;
	_tmp15_ = self->metadata;
	_tmp16_ = self->next_undone_preview;
	_tmp17_ = pdfpc_metadata_pdf_user_slide_to_real_slide (_tmp15_, _tmp16_);
	_tmp18_ = pdfpc_renderer_cache_base_retrieve (_tmp14_, (guint) _tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = pixmap_width;
	_tmp21_ = pixmap_height;
	gdk_pixbuf_get_from_drawable (_tmp13_, (GdkDrawable*) _tmp19_, NULL, 0, 0, 0, 0, _tmp20_, _tmp21_);
	_g_object_unref0 (_tmp19_);
	_tmp22_ = pixbuf;
	_tmp23_ = self->target_width;
	_tmp24_ = self->target_height;
	_tmp25_ = gdk_pixbuf_scale_simple (_tmp22_, _tmp23_, _tmp24_, GDK_INTERP_BILINEAR);
	pixbuf_scaled = _tmp25_;
	memset (&iter, 0, sizeof (GtkTreeIter));
	_tmp26_ = self->slides;
	_tmp27_ = self->next_undone_preview;
	_tmp28_ = g_strdup_printf ("%i", _tmp27_);
	_tmp29_ = _tmp28_;
	gtk_tree_model_get_iter_from_string ((GtkTreeModel*) _tmp26_, &_tmp30_, _tmp29_);
	iter = _tmp30_;
	_g_free0 (_tmp29_);
	_tmp31_ = self->slides;
	_tmp32_ = iter;
	_tmp33_ = pixbuf_scaled;
	g_value_init (&_tmp34_, GDK_TYPE_PIXBUF);
	g_value_set_object (&_tmp34_, _tmp33_);
	gtk_list_store_set_value (_tmp31_, &_tmp32_, 0, &_tmp34_);
	G_IS_VALUE (&_tmp34_) ? (g_value_unset (&_tmp34_), NULL) : NULL;
	_tmp35_ = self->next_undone_preview;
	self->next_undone_preview = _tmp35_ + 1;
	_tmp36_ = self->next_undone_preview;
	_tmp37_ = self->n_slides;
	result = _tmp36_ < _tmp37_;
	_g_object_unref0 (pixbuf_scaled);
	_g_object_unref0 (pixbuf);
	return result;
}


/**
         * Gives the cache to retrieve the images from. The caching process
         * itself should already be finished.
         */
void pdfpc_window_overview_set_cache (pdfpcWindowOverview* self, pdfpcRendererCacheBase* cache) {
	pdfpcRendererCacheBase* _tmp0_;
	pdfpcRendererCacheBase* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cache != NULL);
	_tmp0_ = cache;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->cache);
	self->cache = _tmp1_;
	pdfpc_window_overview_fill_previews (self);
}


/**
         * Set the number of slides. If it is different to what we know, it
         * triggers a rebuilding of the widget.
         */
void pdfpc_window_overview_set_n_slides (pdfpcWindowOverview* self, gint n) {
	gint _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = n;
	_tmp1_ = self->n_slides;
	if (_tmp0_ != _tmp1_) {
		gint _tmp2_;
		gint _tmp3_;
		gint currently_selected;
		gint _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _tmp8_;
		_tmp2_ = pdfpc_window_overview_get_current_slide (self);
		_tmp3_ = _tmp2_;
		currently_selected = _tmp3_;
		_tmp4_ = n;
		self->n_slides = _tmp4_;
		pdfpc_window_overview_fill_structure (self);
		_tmp5_ = currently_selected;
		_tmp6_ = self->n_slides;
		if (_tmp5_ >= _tmp6_) {
			gint _tmp7_;
			_tmp7_ = self->n_slides;
			currently_selected = _tmp7_ - 1;
		}
		_tmp8_ = currently_selected;
		pdfpc_window_overview_set_current_slide (self, _tmp8_);
	}
}


/**
         * Remove the current slide from the overview, and set the total number
         * of slides to the new value.  Perpare to regenerate the structure the
         * next time the overview is hidden.
         */
void pdfpc_window_overview_remove_current (pdfpcWindowOverview* self, gint newn) {
	gint _tmp0_;
	GtkTreeIter iter = {0};
	GtkListStore* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GtkTreeIter _tmp6_ = {0};
	GtkListStore* _tmp7_;
	GtkTreeIter _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = newn;
	self->n_slides = _tmp0_;
	memset (&iter, 0, sizeof (GtkTreeIter));
	_tmp1_ = self->slides;
	_tmp2_ = pdfpc_window_overview_get_current_slide (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup_printf ("%i", _tmp3_);
	_tmp5_ = _tmp4_;
	gtk_tree_model_get_iter_from_string ((GtkTreeModel*) _tmp1_, &_tmp6_, _tmp5_);
	iter = _tmp6_;
	_g_free0 (_tmp5_);
	_tmp7_ = self->slides;
	_tmp8_ = iter;
	gtk_list_store_remove (_tmp7_, &_tmp8_);
	_tmp9_ = pdfpc_window_overview_get_current_slide (self);
	_tmp10_ = _tmp9_;
	_tmp11_ = self->n_slides;
	if (_tmp10_ >= _tmp11_) {
		gint _tmp12_;
		_tmp12_ = self->n_slides;
		pdfpc_window_overview_set_current_slide (self, _tmp12_ - 1);
	}
}


/**
         * We handle some "navigation" key presses ourselves. Others are left to
         * the standard IconView controls, the rest are passed back to the
         * PresentationController.
         */
gboolean pdfpc_window_overview_on_key_press (pdfpcWindowOverview* self, GtkWidget* source, GdkEventKey* key) {
	gboolean result = FALSE;
	gboolean handled;
	GdkEventKey _tmp0_;
	guint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	handled = FALSE;
	_tmp0_ = *key;
	_tmp1_ = _tmp0_.keyval;
	switch (_tmp1_) {
		case 0xff51:
		case 0xff55:
		{
			gint _tmp2_;
			gint _tmp3_;
			_tmp2_ = pdfpc_window_overview_get_current_slide (self);
			_tmp3_ = _tmp2_;
			if (_tmp3_ > 0) {
				gint _tmp4_;
				gint _tmp5_;
				_tmp4_ = pdfpc_window_overview_get_current_slide (self);
				_tmp5_ = _tmp4_;
				pdfpc_window_overview_set_current_slide (self, _tmp5_ - 1);
			}
			handled = TRUE;
			break;
		}
		case 0xff53:
		case 0xff56:
		{
			gint _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			_tmp6_ = pdfpc_window_overview_get_current_slide (self);
			_tmp7_ = _tmp6_;
			_tmp8_ = self->n_slides;
			if (_tmp7_ < (_tmp8_ - 1)) {
				gint _tmp9_;
				gint _tmp10_;
				_tmp9_ = pdfpc_window_overview_get_current_slide (self);
				_tmp10_ = _tmp9_;
				pdfpc_window_overview_set_current_slide (self, _tmp10_ + 1);
			}
			handled = TRUE;
			break;
		}
		case 0xff0d:
		{
			pdfpcPresentationController* _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			_tmp11_ = self->presentation_controller;
			_tmp12_ = pdfpc_window_overview_get_current_slide (self);
			_tmp13_ = _tmp12_;
			pdfpc_presentation_controller_goto_user_page (_tmp11_, _tmp13_ + 1);
			break;
		}
		default:
		break;
	}
	result = handled;
	return result;
}


gboolean pdfpc_window_overview_on_mouse_move (pdfpcWindowOverview* self, GtkWidget* source, GdkEventMotion* event) {
	gboolean result = FALSE;
	GtkTreePath* path = NULL;
	GtkIconView* _tmp0_;
	GdkEventMotion _tmp1_;
	gdouble _tmp2_;
	GdkEventMotion _tmp3_;
	gdouble _tmp4_;
	GtkTreePath* _tmp5_ = NULL;
	GtkTreePath* _tmp6_;
	gboolean _tmp7_ = FALSE;
	GtkTreePath* _tmp8_;
	gboolean _tmp14_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (source != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->slides_view;
	_tmp1_ = *event;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = *event;
	_tmp4_ = _tmp3_.y;
	_tmp5_ = gtk_icon_view_get_path_at_pos (_tmp0_, (gint) _tmp2_, (gint) _tmp4_);
	_tmp6_ = _gtk_tree_path_copy0 (_tmp5_);
	_gtk_tree_path_free0 (path);
	path = _tmp6_;
	_tmp8_ = path;
	if (_tmp8_ != NULL) {
		GtkTreePath* _tmp9_;
		gint* _tmp10_ = NULL;
		gint _tmp11_;
		gint _tmp12_;
		gint _tmp13_;
		_tmp9_ = path;
		_tmp10_ = gtk_tree_path_get_indices (_tmp9_);
		_tmp11_ = _tmp10_[0];
		_tmp12_ = pdfpc_window_overview_get_current_slide (self);
		_tmp13_ = _tmp12_;
		_tmp7_ = _tmp11_ != _tmp13_;
	} else {
		_tmp7_ = FALSE;
	}
	_tmp14_ = _tmp7_;
	if (_tmp14_) {
		GtkTreePath* _tmp15_;
		gint* _tmp16_ = NULL;
		gint _tmp17_;
		_tmp15_ = path;
		_tmp16_ = gtk_tree_path_get_indices (_tmp15_);
		_tmp17_ = _tmp16_[0];
		pdfpc_window_overview_set_current_slide (self, _tmp17_);
	}
	result = FALSE;
	_gtk_tree_path_free0 (path);
	return result;
}


gboolean pdfpc_window_overview_on_mouse_release (pdfpcWindowOverview* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton _tmp0_;
	guint _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.button;
	if (_tmp1_ == ((guint) 1)) {
		pdfpcPresentationController* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		_tmp2_ = self->presentation_controller;
		_tmp3_ = pdfpc_window_overview_get_current_slide (self);
		_tmp4_ = _tmp3_;
		pdfpc_presentation_controller_goto_user_page (_tmp2_, _tmp4_ + 1);
	}
	result = FALSE;
	return result;
}


gint pdfpc_window_overview_get_current_slide (pdfpcWindowOverview* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_current_slide;
	result = _tmp0_;
	return result;
}


void pdfpc_window_overview_set_current_slide (pdfpcWindowOverview* self, gint value) {
	gint _tmp0_;
	GtkTreePath* _tmp1_;
	GtkTreePath* path;
	GtkIconView* _tmp2_;
	GtkIconView* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = gtk_tree_path_new_from_indices (_tmp0_, -1);
	path = _tmp1_;
	_tmp2_ = self->slides_view;
	gtk_icon_view_select_path (_tmp2_, path);
	_tmp3_ = self->slides_view;
	gtk_icon_view_set_cursor (_tmp3_, path, NULL, FALSE);
	_gtk_tree_path_free0 (path);
	g_object_notify ((GObject *) self, "current-slide");
}


static void pdfpc_window_overview_class_init (pdfpcWindowOverviewClass * klass) {
	pdfpc_window_overview_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (pdfpcWindowOverviewPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_pdfpc_window_overview_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_pdfpc_window_overview_set_property;
	G_OBJECT_CLASS (klass)->finalize = pdfpc_window_overview_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PDFPC_WINDOW_OVERVIEW_CURRENT_SLIDE, g_param_spec_int ("current-slide", "current-slide", "current-slide", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void pdfpc_window_overview_instance_init (pdfpcWindowOverview * self) {
	self->priv = PDFPC_WINDOW_OVERVIEW_GET_PRIVATE (self);
	self->n_slides = 0;
	self->last_structure_n_slides = 0;
	self->next_undone_preview = 0;
	self->idle_id = (guint) 0;
	self->cache = NULL;
	self->max_width = -1;
	self->max_height = -1;
	self->priv->_current_slide = 0;
}


static void pdfpc_window_overview_finalize (GObject* obj) {
	pdfpcWindowOverview * self;
	self = PDFPC_WINDOW_OVERVIEW (obj);
	_g_object_unref0 (self->slides);
	_g_object_unref0 (self->slides_view);
	_g_object_unref0 (self->metadata);
	_g_object_unref0 (self->cache);
	_g_object_unref0 (self->presentation_controller);
	_g_object_unref0 (self->presenter);
	G_OBJECT_CLASS (pdfpc_window_overview_parent_class)->finalize (obj);
}


/**
     * An overview of all the slides in the form of a table
     */
GType pdfpc_window_overview_get_type (void) {
	static volatile gsize pdfpc_window_overview_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_window_overview_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcWindowOverviewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_window_overview_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcWindowOverview), 0, (GInstanceInitFunc) pdfpc_window_overview_instance_init, NULL };
		GType pdfpc_window_overview_type_id;
		pdfpc_window_overview_type_id = g_type_register_static (GTK_TYPE_SCROLLED_WINDOW, "pdfpcWindowOverview", &g_define_type_info, 0);
		g_once_init_leave (&pdfpc_window_overview_type_id__volatile, pdfpc_window_overview_type_id);
	}
	return pdfpc_window_overview_type_id__volatile;
}


static void _vala_pdfpc_window_overview_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	pdfpcWindowOverview * self;
	self = PDFPC_WINDOW_OVERVIEW (object);
	switch (property_id) {
		case PDFPC_WINDOW_OVERVIEW_CURRENT_SLIDE:
		g_value_set_int (value, pdfpc_window_overview_get_current_slide (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_pdfpc_window_overview_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	pdfpcWindowOverview * self;
	self = PDFPC_WINDOW_OVERVIEW (object);
	switch (property_id) {
		case PDFPC_WINDOW_OVERVIEW_CURRENT_SLIDE:
		pdfpc_window_overview_set_current_slide (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void pdfpc_window_cell_renderer_highlight_real_render (GtkCellRenderer* base, GdkWindow* window, GtkWidget* widget, GdkRectangle* background_area, GdkRectangle* cell_area, GdkRectangle* expose_area, GtkCellRendererState flags) {
	pdfpcWindowCellRendererHighlight * self;
	GdkWindow* _tmp0_;
	GtkWidget* _tmp1_;
	GdkRectangle _tmp2_;
	GdkRectangle _tmp3_;
	GdkRectangle _tmp4_;
	GtkCellRendererState _tmp5_;
	GtkCellRendererState _tmp6_;
	self = (pdfpcWindowCellRendererHighlight*) base;
	g_return_if_fail (window != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (background_area != NULL);
	g_return_if_fail (cell_area != NULL);
	g_return_if_fail (expose_area != NULL);
	_tmp0_ = window;
	_tmp1_ = widget;
	_tmp2_ = *background_area;
	_tmp3_ = *cell_area;
	_tmp4_ = *expose_area;
	_tmp5_ = flags;
	GTK_CELL_RENDERER_CLASS (pdfpc_window_cell_renderer_highlight_parent_class)->render ((GtkCellRenderer*) GTK_CELL_RENDERER_PIXBUF (self), _tmp0_, _tmp1_, &_tmp2_, &_tmp3_, &_tmp4_, _tmp5_);
	_tmp6_ = flags;
	if (_tmp6_ != GTK_CELL_RENDERER_SELECTED) {
		GdkWindow* _tmp7_;
		cairo_t* _tmp8_ = NULL;
		cairo_t* cr;
		cairo_t* _tmp9_;
		GdkRectangle _tmp10_;
		cairo_t* _tmp11_;
		cairo_t* _tmp12_;
		GdkRectangle _tmp13_;
		cairo_t* _tmp14_;
		cairo_t* _tmp15_;
		_tmp7_ = window;
		_tmp8_ = gdk_cairo_create ((GdkDrawable*) _tmp7_);
		cr = _tmp8_;
		_tmp9_ = cr;
		_tmp10_ = *expose_area;
		gdk_cairo_rectangle (_tmp9_, &_tmp10_);
		_tmp11_ = cr;
		cairo_clip (_tmp11_);
		_tmp12_ = cr;
		_tmp13_ = *cell_area;
		gdk_cairo_rectangle (_tmp12_, &_tmp13_);
		_tmp14_ = cr;
		cairo_set_source_rgba (_tmp14_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.2);
		_tmp15_ = cr;
		cairo_fill (_tmp15_);
		_cairo_destroy0 (cr);
	}
}


pdfpcWindowCellRendererHighlight* pdfpc_window_cell_renderer_highlight_construct (GType object_type) {
	pdfpcWindowCellRendererHighlight * self = NULL;
	self = (pdfpcWindowCellRendererHighlight*) g_object_new (object_type, NULL);
	return self;
}


pdfpcWindowCellRendererHighlight* pdfpc_window_cell_renderer_highlight_new (void) {
	return pdfpc_window_cell_renderer_highlight_construct (PDFPC_WINDOW_TYPE_CELL_RENDERER_HIGHLIGHT);
}


static void pdfpc_window_cell_renderer_highlight_class_init (pdfpcWindowCellRendererHighlightClass * klass) {
	pdfpc_window_cell_renderer_highlight_parent_class = g_type_class_peek_parent (klass);
	GTK_CELL_RENDERER_CLASS (klass)->render = pdfpc_window_cell_renderer_highlight_real_render;
}


static void pdfpc_window_cell_renderer_highlight_instance_init (pdfpcWindowCellRendererHighlight * self) {
}


GType pdfpc_window_cell_renderer_highlight_get_type (void) {
	static volatile gsize pdfpc_window_cell_renderer_highlight_type_id__volatile = 0;
	if (g_once_init_enter (&pdfpc_window_cell_renderer_highlight_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pdfpcWindowCellRendererHighlightClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdfpc_window_cell_renderer_highlight_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pdfpcWindowCellRendererHighlight), 0, (GInstanceInitFunc) pdfpc_window_cell_renderer_highlight_instance_init, NULL };
		GType pdfpc_window_cell_renderer_highlight_type_id;
		pdfpc_window_cell_renderer_highlight_type_id = g_type_register_static (GTK_TYPE_CELL_RENDERER_PIXBUF, "pdfpcWindowCellRendererHighlight", &g_define_type_info, 0);
		g_once_init_leave (&pdfpc_window_cell_renderer_highlight_type_id__volatile, pdfpc_window_cell_renderer_highlight_type_id);
	}
	return pdfpc_window_cell_renderer_highlight_type_id__volatile;
}



